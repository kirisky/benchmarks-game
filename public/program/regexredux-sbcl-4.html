<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>regex-redux Lisp SBCL&nbsp;#4 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The&nbsp;<small>22.01 Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>regex-redux Lisp SBCL&nbsp;#4 program</h1>
    <aside>
      <p><a href="../description/regexredux.html#regexredux">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">;;; The Computer Language Benchmarks Game</span>
<span class="slc">;;; https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">;;;</span>
<span class="slc">;;; regex-dna program contributed by: Witali Kusnezow 2009-03-02</span>
<span class="slc">;;; converted from regex-dna program</span>
<span class="slc">;;; fixed by Antonio Saade</span>

(<span class="kwa">eval-when</span> (:compile-toplevel :load-toplevel :execute)
  (<span class="kwa">require</span> :asdf)
  (<span class="kwa">require</span> :cl-ppcre)

#+sb-thread
(<span class="kwa">progn</span>
  (<span class="kwa">define-alien-routine</span> sysconf long (<span class="kwa">name</span> int))
  (<span class="kwa">use-package</span> :sb-thread)))

(<span class="kwa">eval-when</span> (:compile-toplevel)
(<span class="kwa">setf</span> cl-ppcre:*regex-char-code-limit* <span class="num">128</span>))

(<span class="kwa">defconstant</span>  +regex-list+
  &apos;(<span class="str">&quot;agggtaaa|tttaccct&quot;</span>
    <span class="str">&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</span>
    <span class="str">&quot;a[act]ggtaaa|tttacc[agt]t&quot;</span>
    <span class="str">&quot;ag[act]gtaaa|tttac[agt]ct&quot;</span>
    <span class="str">&quot;agg[act]taaa|ttta[agt]cct&quot;</span>
    <span class="str">&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</span>
    <span class="str">&quot;agggt[cgt]aa|tt[acg]accct&quot;</span>
    <span class="str">&quot;agggta[cgt]a|t[acg]taccct&quot;</span>
    <span class="str">&quot;agggtaa[cgt]|[acg]ttaccct&quot;</span>))

(<span class="kwa">defconstant</span>  +alternatives+
  &apos;((<span class="str">&quot;tHa[Nt]&quot;</span> <span class="str">&quot;&lt;4&gt;&quot;</span>)  (<span class="str">&quot;aND|caN|Ha[DS]|WaS&quot;</span> <span class="str">&quot;&lt;3&gt;&quot;</span>)
    (<span class="str">&quot;a[NSt]|BY&quot;</span> <span class="str">&quot;&lt;2&gt;&quot;</span>)  (<span class="str">&quot;&lt;[^&gt;]*&gt;&quot;</span> <span class="str">&quot;|&quot;</span>)
    (<span class="str">&quot;</span><span class="esc">\\</span><span class="str">|[^|][^|]*</span><span class="esc">\\</span><span class="str">|&quot;</span> <span class="str">&quot;-&quot;</span>)))

#+sb-thread
(<span class="kwa">progn</span>
  (<span class="kwa">defconstant</span>  +cpu-count+ (<span class="kwa">sysconf</span> <span class="num">84</span>))
  (<span class="kwa">defvar</span> *mutex* (<span class="kwa">make-mutex</span>))
  (<span class="kwa">defvar</span> *aux-mutex* (<span class="kwa">make-mutex</span>))

  (<span class="kwa">defmacro</span> bg  (&amp;body body) `(<span class="kwa">make-thread</span> (<span class="kwa">lambda</span> () ,&#64;body)))
  (<span class="kwa">defmacro</span> join-all (&amp;body body)
	`(<span class="kwa">mapcar</span>
	  #&apos;join-thread
	  (<span class="kwa">loop</span> for item in (<span class="kwa">list</span> ,&#64;body)
		 append (<span class="kwa">if</span> (<span class="kwa">consp</span> item) item (<span class="kwa">list</span> item))))))

(<span class="kwa">defun</span> read-all
    (<span class="kwa">stream</span> &amp;aux (<span class="kwa">buf-size</span> (* <span class="num">1024 1024</span>))
     (<span class="kwa">size</span> <span class="num">0</span>)
     (<span class="kwa">buf-list</span>
      (<span class="kwa">loop</span>
         for buf = (<span class="kwa">make-string</span> buf-size :element-type &apos;base-char)
         for len = (<span class="kwa">read-sequence</span> buf stream)
         do (<span class="kwa">incf</span> size len)
         collect (<span class="kwa">if</span> (&lt; len buf-size) (<span class="kwa">subseq</span> buf <span class="num">0</span> len) buf)
         while (= len buf-size))))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> fixnum size))
  (<span class="kwa">loop</span> with res-string = (<span class="kwa">make-string</span> size :element-type &apos;base-char)
     with i of-type fixnum = <span class="num">0</span>
     for str in buf-list
     do (<span class="kwa">setf</span> (<span class="kwa">subseq</span> res-string i) (<span class="kwa">the</span> simple-base-string str))
     (<span class="kwa">incf</span> i (<span class="kwa">length</span> (<span class="kwa">the</span> simple-base-string str)))
     finally (<span class="kwa">return</span> res-string)))

(<span class="kwa">defun</span> length-to-replace (<span class="kwa">match</span>)
  (<span class="kwa">loop</span> for x in match
     sum (<span class="kwa">-</span> (<span class="kwa">the</span> fixnum (<span class="kwa">cdr</span> x))
            (<span class="kwa">the</span> fixnum (<span class="kwa">car</span> x))) of-type fixnum))

(<span class="kwa">defun</span> replace-aux
    (<span class="kwa">match</span> replacement target-string result-string
     &amp;key (<span class="kwa">match-begin</span> <span class="num">0</span>) (<span class="kwa">match-end</span> -<span class="num">1</span>)
     (<span class="kwa">match-length</span> (<span class="kwa">length</span> match))
     &amp;aux
     (<span class="kwa">len</span> (<span class="kwa">length</span> replacement))
     (<span class="kwa">first-match</span> (<span class="kwa">if</span> (<span class="kwa">zerop</span> match-begin) &apos;(<span class="kwa">0</span> . <span class="num">0</span>) (<span class="kwa">nth</span> (<span class="kwa">1-</span> match-begin) match)))
     (<span class="kwa">target-start</span> (<span class="kwa">cdr</span> first-match))
     (<span class="kwa">result-start</span> (+ (<span class="kwa">the</span> fixnum (* len match-begin))
                    (<span class="kwa">-</span> target-start
                       (<span class="kwa">the</span> fixnum (<span class="kwa">length-to-replace</span> (<span class="kwa">subseq</span> match <span class="num">0</span> match-begin)))))))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> fixnum match-begin match-end match-length target-start result-start len)
           (<span class="kwa">type</span> list match)
           (<span class="kwa">type</span> simple-base-string result-string target-string)
           (<span class="kwa">type</span> vector replacement))
  (<span class="kwa">loop</span> with (<span class="kwa">i</span> j) of-type fixnum = (<span class="kwa">list</span> result-start target-start)
     with mmatch = (<span class="kwa">if</span> (&gt; match-begin match-end)
                       match (<span class="kwa">subseq</span> match match-begin match-end))
     for pair in mmatch
     do (<span class="kwa">setf</span> (<span class="kwa">subseq</span> result-string i) (<span class="kwa">subseq</span> target-string j (<span class="kwa">car</span> pair))
              i (+ i (<span class="kwa">-</span> (<span class="kwa">the</span> fixnum (<span class="kwa">car</span> pair)) j))
              (<span class="kwa">subseq</span> result-string i) replacement
              j (<span class="kwa">cdr</span> pair)
              i (+ i len))
     finally (<span class="kwa">if</span> (<span class="kwa">or</span> (<span class="kwa">minusp</span> match-end) (&lt;= match-length match-end))
                 (<span class="kwa">setf</span> (<span class="kwa">subseq</span> result-string i ) (<span class="kwa">subseq</span> target-string j))))
  nil)

#+sb-thread
(<span class="kwa">defun</span> parts
    (<span class="kwa">parts-num</span> len
     &amp;aux
     (<span class="kwa">ranges</span> (<span class="kwa">loop</span> with (<span class="kwa">step</span> rest) of-type fixnum =  (<span class="kwa">multiple-value-list</span> (<span class="kwa">floor</span> len parts-num))
                with i of-type fixnum = <span class="num">0</span> while (&lt; i len)
                collect i into res of-type fixnum
                do (<span class="kwa">incf</span> i step)(<span class="kwa">if</span> (<span class="kwa">plusp</span> rest) (<span class="kwa">progn</span> (<span class="kwa">incf</span> i) (<span class="kwa">decf</span> rest)) )
                finally (<span class="kwa">return</span> (<span class="kwa">append</span> res (<span class="kwa">list</span> len))))
             ))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> fixnum len parts-num)
           (<span class="kwa">type</span> list ranges))
  (<span class="kwa">mapcar</span> #&apos;cons ranges (<span class="kwa">subseq</span> ranges <span class="num">1</span>)))

(<span class="kwa">defun</span> replace-all
    (<span class="kwa">regexp</span> replacement target-string
     &amp;aux (<span class="kwa">rmatch</span> &apos;()) (<span class="kwa">match</span> &apos;())
     (<span class="kwa">result-string</span> (<span class="kwa">make-string</span> <span class="num">0</span> :element-type &apos;base-char)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> simple-base-string result-string target-string)
           (<span class="kwa">type</span> vector replacement))
  (<span class="kwa">cl-ppcre</span>:do-scans
      (<span class="kwa">match-start</span> match-end reg-starts reg-ends regexp target-string nil)
    (<span class="kwa">push</span> (<span class="kwa">cons</span> match-start match-end) rmatch))
  (<span class="kwa">if</span> rmatch
      (<span class="kwa">progn</span>
        (<span class="kwa">setf</span> match (<span class="kwa">reverse</span> rmatch)
              result-string (<span class="kwa">make-string</span>
                             (+ (<span class="kwa">-</span> (<span class="kwa">length</span> target-string)
                                   (<span class="kwa">length-to-replace</span> match))
                                (<span class="kwa">the</span> fixnum (* (<span class="kwa">length</span> replacement)
                                               (<span class="kwa">length</span> match)))) :element-type &apos;base-char))
        #-sb-thread
        (<span class="kwa">replace-aux</span> match replacement target-string result-string)
        #+sb-thread
        (<span class="kwa">mapcar</span> #&apos;join-thread
                (<span class="kwa">loop</span> with len of-type fixnum = (<span class="kwa">length</span> match)
				   with parts-list  = (<span class="kwa">parts</span> +cpu-count+ len)
                   with current of-type fixnum = <span class="num">0</span>
                   repeat +cpu-count+
                   collect
					 (<span class="kwa">bg</span> (<span class="kwa">let</span> (<span class="kwa">range</span>)
                           (<span class="kwa">with-mutex</span> (*mutex*)
                             (<span class="kwa">setf</span> range (<span class="kwa">nth</span> current parts-list))
                             (<span class="kwa">incf</span> current))
                           (<span class="kwa">replace-aux</span> match replacement target-string result-string
                                        :match-begin (<span class="kwa">car</span> range) :match-end (<span class="kwa">cdr</span> range)
                                        :match-length len)))))
        result-string)
      target-string))

(<span class="kwa">defun</span> main (&amp;optional (<span class="kwa">stream</span> *standard-input*)
             &amp;aux (<span class="kwa">sequence</span> (<span class="kwa">read-all</span> stream))
             (<span class="kwa">size</span> (<span class="kwa">length</span> sequence)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> simple-base-string sequence))
  (<span class="kwa">setf</span> sequence (<span class="kwa">replace-all</span> <span class="str">&quot;&gt;[^</span><span class="esc">\\</span><span class="str">n]*</span><span class="esc">\\</span><span class="str">n|</span><span class="esc">\\</span><span class="str">n&quot;</span> <span class="str">&quot;&quot;</span> sequence))

  #-sb-thread
  (<span class="kwa">progn</span>
    (<span class="kwa">loop</span> for regex in +regex-list+ do
         (<span class="kwa">format</span> t <span class="str">&quot;~a ~a~%&quot;</span> regex
                 (/ (<span class="kwa">length</span>
                     (<span class="kwa">the</span> list
                       (<span class="kwa">cl-ppcre</span>:all-matches regex sequence))) <span class="num">2</span>)))
    (<span class="kwa">format</span> t <span class="str">&quot;~%~a~%~a~%&quot;</span> size (<span class="kwa">length</span> sequence))
    (<span class="kwa">loop</span> for pair in +alternatives+ do
         (<span class="kwa">setf</span> sequence (<span class="kwa">replace-all</span>  (<span class="kwa">car</span> pair) (<span class="kwa">cadr</span> pair) sequence )))
    (<span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> (<span class="kwa">length</span> sequence)))
  #+sb-thread
  (<span class="kwa">let</span>* ((<span class="kwa">len</span> (<span class="kwa">length</span> +regex-list+))
         (<span class="kwa">result</span> (<span class="kwa">make-list</span> (<span class="kwa">1</span>+ len))))
    (<span class="kwa">join-all</span>
	 (<span class="kwa">loop</span> with idx of-type fixnum = <span class="num">0</span>
		repeat len
		collect
          (<span class="kwa">bg</span> (<span class="kwa">let</span> (<span class="kwa">reg</span> cur)
                (<span class="kwa">with-mutex</span> (*aux-mutex*)
                  (<span class="kwa">setf</span> cur idx reg (<span class="kwa">nth</span> cur +regex-list+))
                  (<span class="kwa">incf</span> idx))
              (<span class="kwa">setf</span> (<span class="kwa">nth</span> cur result)
                    (<span class="kwa">format</span> nil <span class="str">&quot;~a ~a&quot;</span> reg
                            (/ (<span class="kwa">length</span>
                                (<span class="kwa">the</span> list
                                  (<span class="kwa">cl-ppcre</span>:all-matches reg sequence))) <span class="num">2</span>))))))
	 (<span class="kwa">bg</span> (<span class="kwa">loop</span> with seq = (<span class="kwa">copy-seq</span> sequence)
            for pair in +alternatives+ do
              (<span class="kwa">setf</span> seq (<span class="kwa">replace-all</span>  (<span class="kwa">car</span> pair) (<span class="kwa">cadr</span> pair) seq ))
            finally (<span class="kwa">setf</span> (<span class="kwa">nth</span> len result)
                          (<span class="kwa">format</span> nil <span class="str">&quot;~%~a~%~a~%~a&quot;</span> size (<span class="kwa">length</span> sequence) (<span class="kwa">length</span> seq))))))
    (<span class="kwa">format</span> t <span class="str">&quot;~{~a~%~}&quot;</span> result))
  )
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
SBCL 2.2.0


Wed, 12 Jan 2022 03:34:15 GMT

MAKE:
cp: 'regexredux.sbcl-4.sbcl' and './regexredux.sbcl-4.sbcl' are the same file
SBCL built with: /opt/src/sbcl-2.2.0/bin/sbcl --userinit /dev/null --batch --eval '(load &quot;regexredux.sbcl-4.sbcl_compile&quot;)'
### START regexredux.sbcl-4.sbcl_compile
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (require :sb-concurrency)      (load (compile-file &quot;regexredux.sbcl-4.sbcl&quot; ))) (save-lisp-and-die &quot;sbcl.core&quot; :purify t)
### END regexredux.sbcl-4.sbcl_compile

; compiling file &quot;/home/dunham/all-benchmarksgame/benchmarksgame_i53330/regexredux/tmp/regexredux.sbcl-4.sbcl&quot; (written 28 SEP 2020 04:58:03 PM):
; 
; caught WARNING:
;   System definition file #P&quot;/home/dunham/common-lisp/cl-ppcre/cl-ppcre.asd&quot; contains definition for system &quot;cl-ppcre-test&quot;. Please only define &quot;cl-ppcre&quot; and secondary systems with a name starting with &quot;cl-ppcre/&quot; (e.g. &quot;cl-ppcre/test&quot;) in that file.
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/packages.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/packages-tmpGHU3ALSV.fasl
; compilation finished in 0:00:00.012
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/specials.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/specials-tmpAAURSO1.fasl
; compilation finished in 0:00:00.016
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/util.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/util.lisp
; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; in: DEFUN COMPLEMENT*
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/util-tmp5GEXGEG5.fasl
; compilation finished in 0:00:00.052
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/errors.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/errors-tmpAR3FSGEY.fasl
; compilation finished in 0:00:00.020
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/charset.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/charset.lisp
; in: DEFUN MIX
;     (+ CL-PPCRE::CODE CL-PPCRE::HASH)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFUN COMPUTE-INDEX
;     (LENGTH VECTOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT
;                               (RATIONAL (-4611686018427387899)
;                                         (4611686018427387899))), not a FLOAT.
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR FLOAT
;                               (RATIONAL (-4611686018427387899)
;                                         (4611686018427387899))), not a RATIONAL.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR FLOAT
;                               (RATIONAL (-4611686018427387899)
;                                         (4611686018427387899))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT
;                               (RATIONAL (-4611686018427387899)
;                                         (4611686018427387899))), not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR FLOAT
;                                   (RATIONAL (-4611686018427387899)
;                                             (4611686018427387899))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a (OR FLOAT
;                                   (RATIONAL (-4611686018427387899)
;                                             (4611686018427387899))), not a (SIGNED-BYTE
;                                                                             64).
;       The result is a (VALUES
;                        (OR FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (RATIONAL (-4611686018427387900)
;                                         (9223372036854775798)), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (RATIONAL (-4611686018427387900)
;                                         (9223372036854775798)), not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (RATIONAL (-4611686018427387899)
;                                         (9223372036854775798)), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (RATIONAL (-4611686018427387899)
;                                         (9223372036854775798)), not a FIXNUM.
;       etc.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR FLOAT
;                                   (RATIONAL (-4611686018427387899)
;                                             (4611686018427387899))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR FLOAT
;                            (RATIONAL (-4611686018427387898)
;                                      (4611686018427387900)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR FLOAT
;                                   (RATIONAL (-4611686018427387899)
;                                             (4611686018427387899))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR FLOAT
;                            (RATIONAL (-4611686018427387898)
;                                      (4611686018427387900)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN %ADD-TO-CHARSET/EXPAND
;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to
;   associate */(* /) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (&gt;= CL-PPCRE::NEW-SIZE 371370)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT * 371370.0d0)
;                               (SINGLE-FLOAT * 371370.0)
;                               (RATIONAL * 371370)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&gt;= CL-PPCRE::NEW-SIZE 371370)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (* 2 (LENGTH CL-PPCRE::OLD-VECTOR))
; 
; note: doing unsigned word to integer coercion (cost 20), for:
;       the first result of inline ASH

; in: DEFUN MAP-CHARSET
;     (DECF CL-PPCRE::N)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER * 4611686018427387903), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 4611686018427387902) &amp;OPTIONAL), not a (VALUES
;                                                                                  FIXNUM
;                                                                                  &amp;REST
;                                                                                  T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER * 4611686018427387903), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 4611686018427387902) &amp;OPTIONAL), not a (VALUES
;                                                                                  FIXNUM
;                                                                                  &amp;REST
;                                                                                  T).
;       etc.

; in: DEFUN CREATE-CHARSET-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH CL-PPCRE::CHARSET = (CL-PPCRE::MAKE-CHARSET)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --&gt; LET LET LET TAGBODY WHEN IF &gt;= 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/charset-tmpJAIDFZTC.fasl
; compilation finished in 0:00:00.052
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/charmap.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/charmap.lisp
; in: DEFUN MAKE-CHARMAP
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; in: DEFUN CREATE-CHARMAP-FROM-TEST-FUNCTION
;     (1- CL-PPCRE::END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; LET LET TAGBODY WHEN IF 
; ==&gt;
;   (&lt; CL-PPCRE::CODE #:LOOP-LIMIT-23)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; LET LET TAGBODY WHEN IF &gt;= 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (1- CL-PPCRE::END)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; LET LET TAGBODY WHEN IF 
; ==&gt;
;   (&lt; CL-PPCRE::CODE #:LOOP-LIMIT-23)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/charmap-tmp8V3J6PE9.fasl
; compilation finished in 0:00:00.052
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/chartest.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/chartest.lisp
; in: DEFUN CREATE-HASH-TABLE-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH HASH-TABLE = (MAKE-HASH-TABLE)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --&gt; LET LET LET TAGBODY WHEN IF &gt;= 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFUN CREATE-OPTIMIZED-TEST-FUNCTION
;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (SIGNED-BYTE 64).
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR FLOAT (RATIONAL (-2) (2))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (SIGNED-BYTE 64).
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR FLOAT (RATIONAL (-2) (2))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt;= (HASH-TABLE-COUNT HASH-TABLE)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt;= (CL-PPCRE::CHARSET-COUNT CL-PPCRE::CHARSET)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/chartest-tmp9V47YWQF.fasl
; compilation finished in 0:00:00.016
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/lexer.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/lexer.lisp
; in: DEFUN NEXT-CHAR
;     (- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER) 2)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFUN GET-NUMBER
;     (IF (&lt; CL-PPCRE::END-POS CL-PPCRE::LEXER-LEN)
;         CL-PPCRE::END-POS
;         CL-PPCRE::LEXER-LEN)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN UNESCAPE-CHAR
;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/lexer-tmp9BN22RMA.fasl
; compilation finished in 0:00:00.124
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/parser.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/parser.lisp
; in: DEFUN GROUP
;     (+ CL-PPCRE::OPEN-PAREN-POS 2)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/parser-tmp1CXFJSK9.fasl
; compilation finished in 0:00:00.016
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/regex-class.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (COERCE CL-PPCRE::STR-SLOT 'SIMPLE-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/regex-class-tmpX4BRKI0R.fasl
; compilation finished in 0:00:00.012
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/regex-class-util.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST (SIMPLE-ARRAY * (*))
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;          (CL-PPCRE::EVERYTHINGP (FIRST CL-PPCRE::CHOICES)))
; --&gt; = 
; ==&gt;
;   (LENGTH
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::CHOICES)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::CHOICES)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (AND CL-PPCRE::MAXIMUM (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;          (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))
; --&gt; IF = 
; ==&gt;
;   1
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a (COMPLEX
;                                                                DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a (OR
;                                                                (COMPLEX
;                                                                 SINGLE-FLOAT)
;                                                                (COMPLEX
;                                                                 DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0)
;                                   (SINGLE-FLOAT 1.0 1.0) (INTEGER 1 1)
;                                   (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                                   (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                                   (COMPLEX (INTEGER 1 1))), not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0)
;                                   (SINGLE-FLOAT 1.0 1.0) (INTEGER 1 1)
;                                   (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                                   (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                                   (COMPLEX (INTEGER 1 1))), not a (COMPLEX
;                                                                    DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           IF (NOT CL-PPCRE::LEN)
;           DO ...)
; --&gt; LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==&gt;
;   (+ #:LOOP-SUM-5 CL-PPCRE::LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;          (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;           NIL))
; --&gt; SYMBOL-MACROLET IF 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;           NIL))
; --&gt; SYMBOL-MACROLET IF 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::SUM CL-PPCRE::LEN)
; --&gt; LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==&gt;
;   (+ #:LOOP-SUM-5 CL-PPCRE::LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                           CL-PPCRE::ALTERNATION)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::MINIMIZE CL-PPCRE::LEN)
; --&gt; LET LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --&gt; SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF &lt; IF 
; ==&gt;
;   (&lt; #:LOOP-MAXMIN-TEMP-9 #:LOOP-MAXMIN-8)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;          (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;          (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;           CL-PPCRE::START-POS))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;           NIL))
; --&gt; SYMBOL-MACROLET IF + 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --&gt; SYMBOL-MACROLET IF 
; ==&gt;
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::MINIMUM))
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::LEN))))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; SYMBOL-MACROLET IF + 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; --&gt; SYMBOL-MACROLET IF 
; ==&gt;
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::MINIMUM))
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::LEN))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/regex-class-util-tmpQ371UGST.fasl
; compilation finished in 0:00:00.112
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/convert.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/convert.lisp
; in: DEFUN CONVERT-CHAR-CLASS-TO-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAYBE-ACCUMULATE
;     (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                   (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                      (CL-PPCRE::LEN CL-PPCRE::STR)))
;             (CL-PPCRE::STR CL-PPCRE::STR)
;           (CL-PPCRE::SKIP CL-PPCRE::STR) T)
; --&gt; SETF LET* 
; ==&gt;
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY * (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &amp;REST T).

;     (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BRANCH) T)
;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :GREEDY-REPETITION) T)
;     (ZEROP LENGTH)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :NAMED-REGISTER) T)
;     (COPY-SEQ (SECOND CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BACK-REFERENCE) T)
;     (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR STRING SYMBOL CHARACTER), not a STRING.
;   The second argument is a (OR STRING (AND (NOT NULL) SYMBOL)
;                                CHARACTER), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR STRING SYMBOL CHARACTER), not a SIMPLE-STRING.
;   The second argument is a (OR STRING (AND (NOT NULL) SYMBOL)
;                                CHARACTER), not a SIMPLE-STRING.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).

;     (1- CL-PPCRE::BACKREF-NUMBER)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).

;     (COPY-SEQ CL-PPCRE::BACKREF-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &amp;REST T).
;       etc.

;     (1- CL-PPCRE::BACKREF-NUMBER)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::NAME CL-PPCRE::IN CL-PPCRE::REG-NAMES
;           CL-PPCRE::FOR CL-PPCRE::REG-INDEX CL-PPCRE::FROM 0
;           WHEN (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
;           CL-PPCRE::COLLECT ...)
; --&gt; LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* TAGBODY 
; --&gt; SB-LOOP::LOOP-DESETQ SETQ THE 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

; in: DEFUN CONVERT
;     (COERCE (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR) 'SIMPLE-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/convert-tmp2OWI3Q7U.fasl
; compilation finished in 0:00:00.140
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/optimize.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (MAKE-ARRAY CL-PPCRE::COLLECTOR-LENGTH :INITIAL-CONTENTS CL-PPCRE::COLLECTOR
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a SIMPLE-BASE-STRING.

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --&gt; THE 
; ==&gt;
;   (+ (CL-PPCRE::LEN CL-PPCRE::ELEMENT) CL-PPCRE::COLLECTOR-LENGTH)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;             (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;           CL-PPCRE::SKIP (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --&gt; SETF LET* 
; ==&gt;
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES (SIMPLE-ARRAY * (*))
;                                                            &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &amp;REST T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --&gt; THE 
; ==&gt;
;   (+ (CL-PPCRE::LEN CL-PPCRE::ELEMENT) CL-PPCRE::COLLECTOR-LENGTH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAKE-ARRAY CL-PPCRE::CONCATENATED-LENGTH :INITIAL-CONTENTS
;                 (REVERSE (CL-PPCRE::STR CL-PPCRE::CONCATENATED-START))
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST (SIMPLE-ARRAY * (*))
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST (SIMPLE-ARRAY * (*))
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST (SIMPLE-ARRAY * (*))
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a SIMPLE-BASE-STRING.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CHOICE CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                        CL-PPCRE::ALTERNATION)
;           CL-PPCRE::MINIMIZE (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;                               CL-PPCRE::CURRENT-MIN-REST))
; --&gt; LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --&gt; SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF &lt; IF 
; ==&gt;
;   (&lt; #:LOOP-MAXMIN-TEMP-10 #:LOOP-MAXMIN-9)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST)
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/optimize-tmp9KKTJMYV.fasl
; compilation finished in 0:00:00.072
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/closures.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/closures.lisp
; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                 (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (- CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::CHAR-CLASS
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::START-POS))
;       (LAMBDA (CL-PPCRE::START-POS)
;         (DECLARE (FIXNUM CL-PPCRE::START-POS))
;         (AND (&lt; CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;              (CL-PPCRE::CHAR-CLASS-TEST)
;              (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS)))))
; --&gt; LET LAMBDA FUNCTION AND IF IF FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS) CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS VECTOR
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::END-STRING CL-PPCRE::START-POS
;      CL-PPCRE::TEST-END-POS 0 CL-PPCRE::END-STRING-LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::START-POS
;      CL-PPCRE::NEXT-POS 0 CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-MATCHER-AUX (BACK-REFERENCE T)
;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::*STRING* CL-PPCRE::START-POS
;      CL-PPCRE::NEXT-POS CL-PPCRE::REG-START CL-PPCRE::REG-END)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::START-POS
;        (- (THE FIXNUM CL-PPCRE::REG-END) (THE FIXNUM CL-PPCRE::REG-START)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a (INTEGER -9223372036854775807
;                                 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a (INTEGER -9223372036854775807
;                                 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+

; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   FN is not known to be a function

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   NEXT-FN is not known to be a function


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/closures-tmpJU0JWO19.fasl
; compilation finished in 0:00:00.116
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/repetition-closures.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET BLOCK 
; --&gt; TAGBODY WHEN IF FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; SETF LET* FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; LOOP BLOCK LET LET TAGBODY UNLESS IF FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LAMBDA FUNCTION LET MIN 
; ==&gt;
;   1
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; SETF LET* FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --&gt; LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA FUNCTION 
; --&gt; LET AND IF IF LOOP BLOCK LET TAGBODY UNLESS IF AND IF FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS CL-PPCRE::NEXT-POS
;                               0 CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (LET ((CL-PPCRE::NEXT-POS (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)))
;        (DECLARE (FIXNUM CL-PPCRE::NEXT-POS))
;        (AND
;         (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS CL-PPCRE::NEXT-POS
;                              0 CL-PPCRE::LEN)
;         CL-PPCRE::NEXT-POS)))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (LET ((CL-PPCRE::NEXT-POS (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)))
;        (DECLARE (FIXNUM CL-PPCRE::NEXT-POS))
;        (AND
;         (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                   CL-PPCRE::NEXT-POS 0 CL-PPCRE::LEN)
;         CL-PPCRE::NEXT-POS)))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;           (1+ CL-PPCRE::CURR-POS)))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND
;       (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;       (1+ CL-PPCRE::CURR-POS)))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --&gt; LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA FUNCTION 
; --&gt; LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;           (1+ CL-PPCRE::CURR-POS)))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; SETF LET* FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; + AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; SB-IMPL::XSUBTRACT AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; FUNCALL 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (AND CL-PPCRE::MAXIMUM (ZEROP CL-PPCRE::MAXIMUM))
; --&gt; ZEROP 
; ==&gt;
;   1
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
; --&gt; = 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; PLUSP 
; ==&gt;
;   1
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN) (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF PLUSP 
; ==&gt;
;   1
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; PLUSP 
; ==&gt;
;   1
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
; --&gt; = 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (AND (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM) CL-PPCRE::LEN
;          (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF 
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (COND
;      ((AND CL-PPCRE::MAXIMUM (ZEROP CL-PPCRE::MAXIMUM))
;       (ERROR &quot;Got REPETITION with MAXIMUM 0 (should not happen)&quot;))
;      ((AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
;       (ERROR &quot;Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)&quot;))
;      ((AND (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM) CL-PPCRE::LEN
;            (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;        CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;      ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;       (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::GREEDYP
;            (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1)))
;       (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      (CL-PPCRE::GREEDYP
;       (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN)
;            (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
;       (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      (T
;       (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN)))
; --&gt; IF IF IF 
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; PLUSP 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN) (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF PLUSP 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; PLUSP 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/repetition-closures-tmpZX2WN8N4.fasl
; compilation finished in 0:00:00.248
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/scanner.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (CL-PPCRE::BMH-MATCHER-AUX :CASE-INSENSITIVE-P T)
; --&gt; FUNCTION IF LOOP BLOCK LET TAGBODY LOOP BLOCK LET LET TAGBODY UNLESS IF 
; --&gt; AND IF CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN CL-PPCRE::*STRING* :START2 CL-PPCRE::START-POS
;             :END2 CL-PPCRE::*END-POS* :TEST CL-PPCRE::TEST)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN CREATE-CHAR-SEARCHER
;     (CL-PPCRE::CHAR-SEARCHER-AUX :CASE-INSENSITIVE-P T)
; --&gt; FUNCTION AND IF LOOP BLOCK LET LET TAGBODY WHEN IF SETQ THE AND IF 
; --&gt; CHAR-EQUAL 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF AND IF 
; --&gt; NOT 
; ==&gt;
;   1
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK TAGBODY 
; --&gt; PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/scanner-tmpOU81XRV0.fasl
; compilation finished in 0:00:00.380
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/api.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; in: DEFUN SCAN-TO-STRINGS
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MAP 'VECTOR
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (IF CL-PPCRE::REG-START
;                (FUNCALL CL-PPCRE::SUBSTR-FN CL-PPCRE::TARGET-STRING
;                         CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                NIL))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN ALL-MATCHES
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --&gt; LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING3)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --&gt; IF THE COERCE 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a RATIONAL.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --&gt; CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 
; ==&gt;
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 1+ 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a RATIONAL.

; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 
; ==&gt;
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN SPLIT
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF 
; --&gt; THE COERCE 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP CL-PPCRE::LIMIT)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;           CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;           IF CL-PPCRE::REG-START
;           DO ...)
; --&gt; LET LET LET LET TAGBODY SB-LOOP::LOOP-DESETQ SETQ THE AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a RATIONAL.

;     (&gt; CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (&gt;= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR REAL COMPLEX), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR REAL COMPLEX), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (PLUSP CL-PPCRE::LIMIT)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a FIXNUM.
;       etc.

;     (INCF CL-PPCRE::COUNTER)
; --&gt; THE 
; ==&gt;
;   (+ 1 CL-PPCRE::COUNTER)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

;     (&gt;= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a (OR (DOUBLE-FLOAT (0.0d0)) (SINGLE-FLOAT (0.0))
;                                    (RATIONAL (0))), not a FIXNUM.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&gt; CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       etc.

; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING :START
;                  CL-PPCRE::MATCH-START :END CL-PPCRE::MATCH-END)
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (&lt; CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;      (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                     :JUNK-ALLOWED T))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR INTEGER NULL), not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR INTEGER NULL), not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt; CL-PPCRE::TOKEN 0)
; 
; note: forced to do FAST-IF-&lt;-ZERO (cost 9)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

; in: DEFUN BUILD-REPLACEMENT
;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --&gt; MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; 
; note: unable to open code because: can't determine sequence argument type

;     (APPLY CL-PPCRE::TOKEN
;            (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                               CL-PPCRE::MATCH-END)
;            (MAP 'LIST
;                 (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                   (AND CL-PPCRE::REG-START
;                        (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                                           CL-PPCRE::REG-START
;                                           CL-PPCRE::REG-END)))
;                 CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --&gt; MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; 
; note: unable to open code because: can't determine sequence argument type

;     (FUNCALL CL-PPCRE::TOKEN CL-PPCRE::TARGET-STRING CL-PPCRE::START
;              CL-PPCRE::END CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;              CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --&gt; MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.

; ==&gt;
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; ==&gt;
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (WITH-OUTPUT-TO-STRING (CL-PPCRE::S NIL :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
;       (LOOP CL-PPCRE::FOR CL-PPCRE::TOKEN CL-PPCRE::IN CL-PPCRE::REPLACEMENT-TEMPLATE
;             DO (TYPECASE CL-PPCRE::TOKEN
;                  (STRING (WRITE-STRING CL-PPCRE::TOKEN CL-PPCRE::S))
;                  (INTEGER (WHEN # #) (WHEN # #))
;                  (FUNCTION (WRITE-STRING # CL-PPCRE::S))
;                  (SYMBOL (CASE CL-PPCRE::TOKEN # # # # #)))))
; --&gt; LET 
; ==&gt;
;   (MAKE-STRING 31 :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
; 
; note: could not stack allocate:
;        (WITH-OUTPUT-TO-STRING (S NIL :ELEMENT-TYPE ELEMENT-TYPE)
;          (LOOP FOR TOKEN IN REPLACEMENT-TEMPLATE
;                DO (TYPECASE TOKEN
;                     (STRING (WRITE-STRING TOKEN S))
;                     (INTEGER
;                      (WHEN (&gt;= TOKEN REG-BOUND)
;                        (SIGNAL-INVOCATION-ERROR
;                         &quot;Reference to non-existent register ~A in replacement string.&quot;
;                         (1+ TOKEN)))
;                      (WHEN (SVREF REG-STARTS TOKEN)
;                        (WRITE-STRING TARGET-STRING S :START
;                                      (SVREF REG-STARTS TOKEN) :END
;                                      (SVREF REG-ENDS TOKEN))))
;                     (FUNCTION
;                      (WRITE-STRING
;                       (COND
;                        (SIMPLE-CALLS
;                         (APPLY TOKEN
;                                (NSUBSEQ TARGET-STRING MATCH-START MATCH-END)
;                                (MAP 'LIST
;                                     (LAMBDA (REG-START REG-END)
;                                       (AND REG-START
;                                            (NSUBSEQ TARGET-STRING REG-START
;                                                     REG-END)))
;                                     REG-STARTS REG-ENDS)))
;                        (T
;                         (FUNCALL TOKEN TARGET-STRING START END MATCH-START
;                                  MATCH-END REG-STARTS REG-ENDS)))
;                       S))
;                     (SYMBOL
;                      (CASE TOKEN
;                        ((:BACKSLASH) (WRITE-CHAR #\\ S))
;                        ((:MATCH)
;                         (WRITE-STRING TARGET-STRING S :START MATCH-START :END
;                                       MATCH-END))
;                        ((:BEFORE-MATCH)
;                         (WRITE-STRING TARGET-STRING S :START START :END
;                                       MATCH-START))
;                        ((:AFTER-MATCH)
;                         (WRITE-STRING TARGET-STRING S :START MATCH-END :END
;                                       END))
;                        (OTHERWISE
;                         (WRITE-STRING
;                          (COND
;                           (SIMPLE-CALLS
;                            (APPLY TOKEN
;                                   (NSUBSEQ TARGET-STRING MATCH-START MATCH-END)
;                                   (MAP 'LIST
;                                        (LAMBDA (REG-START REG-END)
;                                          (AND REG-START
;                                               (NSUBSEQ TARGET-STRING REG-START
;                                                        REG-END)))
;                                        REG-STARTS REG-ENDS)))
;                           (T
;                            (FUNCALL TOKEN TARGET-STRING START END MATCH-START
;                                     MATCH-END REG-STARTS REG-ENDS)))
;                          S)))))))

;     (&gt;= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --&gt; MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFUN REPLACE-AUX
;     (FUNCALL
;      (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;       CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END)
;      CL-PPCRE::CURR-REPLACEMENT)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (WITH-OUTPUT-TO-STRING (CL-PPCRE::S NIL :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
;       (LOOP CL-PPCRE::FOR (CL-PPCRE::FROM CL-PPCRE::TO) CL-PPCRE::ON (APPEND
;                                                                       (LIST
;                                                                        CL-PPCRE::START)
;                                                                       CL-PPCRE::POS-LIST
;                                                                       (LIST
;                                                                        CL-PPCRE::END))
;             CL-PPCRE::FOR REPLACE = NIL CL-PPCRE::THEN (AND (NOT REPLACE)
;                                                             CL-PPCRE::TO)
;             CL-PPCRE::FOR ...))
; --&gt; LET 
; ==&gt;
;   (MAKE-STRING 31 :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
; 
; note: could not stack allocate:
;        (WITH-OUTPUT-TO-STRING (S NIL :ELEMENT-TYPE ELEMENT-TYPE)
;          (LOOP FOR (FROM TO) ON (APPEND (LIST START) POS-LIST (LIST END))
;                FOR REPLACE = NIL THEN (AND (NOT REPLACE) TO)
;                FOR REG-STARTS = (IF REPLACE
;                                     (POP REG-LIST)
;                                     NIL)
;                FOR REG-ENDS = (IF REPLACE
;                                   (POP REG-LIST)
;                                   NIL)
;                FOR CURR-REPLACEMENT = (IF REPLACE
;                                           (BUILD-REPLACEMENT
;                                            REPLACEMENT-TEMPLATE TARGET-STRING
;                                            START END FROM TO REG-STARTS
;                                            REG-ENDS SIMPLE-CALLS ELEMENT-TYPE)
;                                           NIL)
;                WHILE TO
;                IF REPLACE
;                DO (WRITE-STRING
;                    (IF PRESERVE-CASE
;                        (FUNCALL
;                         (STRING-CASE-MODIFIER TARGET-STRING FROM TO START END)
;                         CURR-REPLACEMENT)
;                        CURR-REPLACEMENT)
;                    S) ELSE
;                DO (WRITE-STRING TARGET-STRING S :START FROM :END TO)))

; in: DEFUN REGEX-REPLACE
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFUN REGEX-REPLACE-ALL
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --&gt; BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF 
; --&gt; THE COERCE 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR LIST
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR LIST
;                                (AND (NOT SIMPLE-BASE-STRING)
;                                     (NOT (SIMPLE-ARRAY CHARACTER (*))) VECTOR)
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     * (*)).

; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a (OR (COMPLEX SINGLE-FLOAT)
;                                                        (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR REAL COMPLEX), not a RATIONAL.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   1
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR REAL COMPLEX), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.2.0-linux-x64/home/dunham/common-lisp/cl-ppcre/api-tmpY2ML9CFA.fasl
; compilation finished in 0:00:00.240


; file: /home/dunham/all-benchmarksgame/benchmarksgame_i53330/regexredux/tmp/regexredux.sbcl-4.sbcl
; in: DEFUN REPLACE-AUX
;     (LOOP WITH (I J) OF-TYPE FIXNUM = (LIST RESULT-START TARGET-START)
;           WITH MMATCH = (IF (&gt; MATCH-BEGIN MATCH-END)
;                             MATCH
;                             (SUBSEQ MATCH MATCH-BEGIN MATCH-END))
;           FOR ...)
; --&gt; LET SB-LOOP::LOOP-DESTRUCTURING-BIND DESTRUCTURING-BIND SB-INT:BINDING* 
; --&gt; LET* IF 
; ==&gt;
;   NIL
; 
; caught STYLE-WARNING:
;   The binding of I is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;
; 
; caught STYLE-WARNING:
;   The binding of J is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;

; in: DEFUN PARTS
;     (LOOP WITH (STEP
;                 REST) OF-TYPE FIXNUM = (MULTIPLE-VALUE-LIST
;                                         (FLOOR LEN PARTS-NUM))
;           WITH I OF-TYPE FIXNUM = ...)
; --&gt; LET SB-LOOP::LOOP-DESTRUCTURING-BIND DESTRUCTURING-BIND SB-INT:BINDING* 
; --&gt; LET* IF 
; ==&gt;
;   NIL
; 
; caught STYLE-WARNING:
;   This is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;
; 
; caught STYLE-WARNING:
;   The binding of REST is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;
; 
; compilation unit finished
;   caught 1 WARNING condition
;   caught 4 STYLE-WARNING conditions
;   printed 1012 notes


; wrote /home/dunham/all-benchmarksgame/benchmarksgame_i53330/regexredux/tmp/regexredux.sbcl-4.fasl
; compilation finished in 0:00:02.364
### START regexredux.sbcl-4.sbcl_run
(main) (quit)
### END regexredux.sbcl-4.sbcl_run


4.98s to complete and log all make actions

COMMAND LINE:
/opt/src/sbcl-2.2.0/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load regexredux.sbcl-4.sbcl_run 0 &lt; regexredux-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
27388361
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

