<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>k-nucleotide Lisp SBCL program (Benchmarks Game) </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The&nbsp;<small>Computer&nbsp;Language</small><br>22.05 Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>k-nucleotide Lisp SBCL program</h1>
    <aside>
      <p><a href="../description/knucleotide.html#knucleotide">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">;;   The Computer Language Benchmarks Game</span>
<span class="slc">;;   https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">;;   contributed by Currell Berry based on Java submission #1</span>
<span class="slc">;;</span>
<span class="slc">;; Note I think you could probably get further performance gains by rebasing the </span>
<span class="slc">;; implementation on Java #6, which is similar to java #1 but does not rely on </span>
<span class="slc">;; the external library it.unimi.dsi.fastutil my testing (once I had already translated</span>
<span class="slc">;; Java #1 to lisp) shows that a great deal of Java #1&apos;s performance comes from it</span>
<span class="slc">;; relying on a specialized hash table fastutil.longs.Long2IntOpenHashMap. </span>

<span class="slc">;(require :alexandria)</span>
(<span class="kwa">defpackage</span> :knucleotide
  (:use :cl))

(<span class="kwa">in-package</span> :knucleotide)

(<span class="kwa">declaim</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">space</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))

<span class="slc">;; simple thread runner implementation</span>
<span class="slc">;; we have a semaphore</span>
(<span class="kwa">defparameter</span> *my-tr-available-thread-semaphore* nil)
<span class="slc">;; each time a thread finishes up, we increment this semaphore</span>
<span class="slc">;; the main thread waits on the semaphore, whenever it goes above 0 it finds</span>
<span class="slc">;; another task if one is available and starts it up</span>

(<span class="kwa">defparameter</span> *my-tr-task-remaining-count* <span class="num">0</span>)
(<span class="kwa">declaim</span> (<span class="kwa">type</span> fixnum *my-tr-task-remaining-count*))
(<span class="kwa">defparameter</span> *my-tr-completed-task-mutex* nil)
(<span class="kwa">defparameter</span> *my-tr-task-completed-cv* nil)

<span class="slc">;;writing to status and result should only be done in my-tr-run</span>
(<span class="kwa">defstruct</span> my-task
  (<span class="kwa">mylambda</span>) <span class="slc">; the thing to run</span>
  (<span class="kwa">status</span> nil) <span class="slc">; nil or t</span>
  (<span class="kwa">result</span> nil))

(<span class="kwa">defparameter</span> *my-task-list* #())
(<span class="kwa">declaim</span> (<span class="kwa">type</span> vector *my-task-list*))

<span class="slc">;; must have set up populated *my-task-list* first</span>
<span class="slc">;; each time a thread becomes available, then we run the next task</span>
(<span class="kwa">defun</span> my-tr-run (<span class="kwa">threadcount</span>)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> fixnum threadcount))
  (<span class="kwa">setf</span> *my-tr-available-thread-semaphore* (<span class="kwa">sb-thread</span>:make-semaphore :count threadcount))
  (<span class="kwa">setf</span> *my-tr-completed-task-mutex* (<span class="kwa">sb-thread</span>:make-mutex)) 
  (<span class="kwa">setf</span> *my-tr-task-remaining-count* (<span class="kwa">length</span> *my-task-list*)) 
  (<span class="kwa">setf</span> *my-tr-task-completed-cv* (<span class="kwa">sb-thread</span>:make-waitqueue)) 
  (<span class="kwa">loop</span> for taskindex from <span class="num">0</span> below (<span class="kwa">length</span> *my-task-list*) do
       (<span class="kwa">sb-thread</span>:wait-on-semaphore *my-tr-available-thread-semaphore*)
       (<span class="kwa">let</span> ((<span class="kwa">thetask</span> (<span class="kwa">elt</span> *my-task-list* taskindex)))
         (<span class="kwa">sb-thread</span>:make-thread (<span class="kwa">lambda</span> () (<span class="kwa">let</span> ((<span class="kwa">results</span>
                                                  (<span class="kwa">funcall</span> (<span class="kwa">my-task-mylambda</span> thetask))))
                                             (<span class="kwa">setf</span> (<span class="kwa">my-task-result</span> thetask) results)
                                             (<span class="kwa">setf</span> (<span class="kwa">my-task-status</span> thetask) t)
                                             (<span class="kwa">sb-thread</span>:signal-semaphore *my-tr-available-thread-semaphore*)
                                             (<span class="kwa">sb-thread</span>:with-mutex (*my-tr-completed-task-mutex*)
                                               (<span class="kwa">decf</span> *my-tr-task-remaining-count*)
                                               (<span class="kwa">sb-thread</span>:condition-notify *my-tr-task-completed-cv*)
                                               )
                                             )))))
  (<span class="kwa">loop</span>
     (<span class="kwa">sb-thread</span>:with-mutex (*my-tr-completed-task-mutex*)
       (<span class="kwa">if</span> (<span class="kwa">eql</span> *my-tr-task-remaining-count* <span class="num">0</span>)
           (<span class="kwa">return</span>)
           (<span class="kwa">sb-thread</span>:condition-wait *my-tr-task-completed-cv* *my-tr-completed-task-mutex*)))))

(<span class="kwa">defconstant</span> CODES  #(<span class="kwa">-1</span> <span class="num">0</span> -<span class="num">1 1 3</span> -<span class="num">1</span> -<span class="num">1 2</span>)) 
(<span class="kwa">defconstant</span> NUCLEOTIDES #(#\A #\C #\G #\T)) 

(<span class="kwa">defun</span> hash-function (<span class="kwa">x</span>)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">64</span>) x))
  x)

(<span class="kwa">defstruct</span> result
  (<span class="kwa">outmap</span> (<span class="kwa">make-hash-table</span>
           :test &apos;eql
           :hash-function #&apos;hash-function
           :rehash-size <span class="num">2.0</span>
           :rehash-threshold <span class="num">0.7</span>))
  (<span class="kwa">keylength</span> <span class="num">0</span>))

(<span class="kwa">defun</span> create-fragment-tasks (<span class="kwa">sequence</span> mfragment-lengths)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">simple-array</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>) (*)) sequence))
  (<span class="kwa">let</span> ((<span class="kwa">tasks</span> (<span class="kwa">make-array</span> <span class="num">46</span> :fill-pointer <span class="num">0</span>)))
    (<span class="kwa">loop</span> for fragmentLength in mfragment-lengths do
         (<span class="kwa">loop</span> for i of-type (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) from <span class="num">0</span> below fragmentLength do
              (<span class="kwa">let</span> ((<span class="kwa">offset</span> i)
                    (<span class="kwa">mfragmentlength</span> fragmentLength))
                <span class="slc">;;(format t &quot;fragmentLength: ~a~%&quot; fragmentLength)</span>
                (<span class="kwa">vector-push-extend</span>
                 (<span class="kwa">make-my-task</span> :mylambda
                               (<span class="kwa">lambda</span> ()
                                 (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) mfragmentlength)
                                          (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) offset))
                                 <span class="slc">;(format t &quot;offset: ~a, fragmentLength: ~a~%&quot; offset mfragmentlength)</span>
                                 (<span class="kwa">create-fragment-map</span> sequence offset mfragmentlength)
                                 ))
                 tasks))))
    tasks))

(<span class="kwa">defun</span> create-fragment-map (<span class="kwa">sequence</span> offset fragmentLength)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">simple-array</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>) (*)) sequence)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) offset)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) fragmentLength))
  (<span class="kwa">let</span>* ((<span class="kwa">res</span> (<span class="kwa">make-result</span> :keylength fragmentLength))
         (<span class="kwa">mymap</span> (<span class="kwa">result-outmap</span> res))
         (<span class="kwa">lastIndex</span> (+ (<span class="kwa">-</span> (<span class="kwa">length</span> sequence) fragmentLength) <span class="num">1</span>)))
    (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) lastIndex))
    (<span class="kwa">loop</span>
       for index of-type (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) from offset below lastIndex by fragmentLength
       do
         (<span class="kwa">let</span>* ((<span class="kwa">key</span> (<span class="kwa">get-key</span> sequence index fragmentLength))
                (<span class="kwa">value</span> (<span class="kwa">gethash</span> key mymap <span class="num">0</span>)))
           (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">64</span>) key)
                    (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) value))
           (<span class="kwa">setf</span> (<span class="kwa">gethash</span> key mymap <span class="num">0</span>) (<span class="kwa">the</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) (+ value <span class="num">1</span>)))))
    res))

(<span class="kwa">defun</span> sum-two-maps (<span class="kwa">result1</span> result2)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">loop</span> for key2 of-type (<span class="kwa">unsigned-byte</span> <span class="num">64</span>) being the hash-keys  of (<span class="kwa">result-outmap</span> result2)
     using (<span class="kwa">hash-value</span> value2) do
       (<span class="kwa">setf</span> (<span class="kwa">gethash</span> key2 (<span class="kwa">result-outmap</span> result1)) (+ (<span class="kwa">the</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) (<span class="kwa">gethash</span> key2 (<span class="kwa">result-outmap</span> result1) <span class="num">0</span>)) (<span class="kwa">the</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) value2))))
  result1
  )

(<span class="kwa">defun</span> write-frequencies (<span class="kwa">totalCount</span> frequencies)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">let</span> ((<span class="kwa">freq</span> (<span class="kwa">make-array</span> (<span class="kwa">hash-table-count</span> (<span class="kwa">result-outmap</span> frequencies)) :fill-pointer <span class="num">0</span> :element-type &apos;cons)))
    (<span class="kwa">loop</span> for key being the hash-keys of (<span class="kwa">result-outmap</span> frequencies)
       using (<span class="kwa">hash-value</span> cnt) do
         (<span class="kwa">let</span> ((<span class="kwa">nentry</span> (<span class="kwa">cons</span> (<span class="kwa">key-to-string</span> key (<span class="kwa">result-keylength</span> frequencies)) cnt)))
           (<span class="kwa">vector-push-extend</span> nentry freq)))
    (<span class="kwa">sort</span> freq (<span class="kwa">lambda</span> (<span class="kwa">x</span> y) (&gt; (<span class="kwa">cdr</span> x) (<span class="kwa">cdr</span> y))))
    (<span class="kwa">let</span> ((<span class="kwa">outstr</span>
           (<span class="kwa">apply</span> #&apos;concatenate 
                  (<span class="kwa">append</span> (<span class="kwa">list</span> &apos;string)
                          (<span class="kwa">loop</span> for index from <span class="num">0</span> below (<span class="kwa">length</span> freq)
                                           for (<span class="kwa">key</span> . value) = (<span class="kwa">elt</span> freq index)
                                           collect 
                                             (<span class="kwa">format</span> nil <span class="str">&quot;~a ~,3f~%&quot;</span> key (/ (* value <span class="num">100.0</span>) totalCount)))))))
      outstr)))

(<span class="kwa">defun</span> write-count (<span class="kwa">tasks</span> nucleotideFragment)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">let</span>* ((<span class="kwa">key</span> (<span class="kwa">to-codes-new</span> (<span class="kwa">map</span> &apos;(<span class="kwa">vector</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>)) #&apos;char-code nucleotideFragment) (<span class="kwa">length</span> nucleotideFragment)) )
         (<span class="kwa">k</span> (<span class="kwa">get-key</span> key <span class="num">0</span> (<span class="kwa">length</span> nucleotideFragment)))
         (<span class="kwa">count</span> <span class="num">0</span>))
    (<span class="kwa">loop</span> for task across tasks 
       for result = (<span class="kwa">my-task-result</span> task) do
         (<span class="kwa">if</span> (<span class="kwa">eql</span> (<span class="kwa">result-keylength</span> result) (<span class="kwa">length</span> nucleotideFragment))
             (<span class="kwa">setf</span> count (+ count (<span class="kwa">gethash</span> k (<span class="kwa">result-outmap</span> result) <span class="num">0</span>)))))
    (<span class="kwa">format</span> nil <span class="str">&quot;~a~c~a~%&quot;</span> count #<span class="esc">\t</span>ab nucleotideFragment)))

(<span class="kwa">defun</span> key-to-string (<span class="kwa">key</span> length)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">64</span>) key)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) length))
  (<span class="kwa">let</span> ((<span class="kwa">res</span> (<span class="kwa">make-string</span> length)))
    (<span class="kwa">loop</span> for i from <span class="num">0</span> below length do
         (<span class="kwa">setf</span> (<span class="kwa">elt</span> res (<span class="kwa">-</span> length i <span class="num">1</span>)) (<span class="kwa">elt</span> NUCLEOTIDES (<span class="kwa">logand</span> key #x3)))
         (<span class="kwa">setf</span> key (<span class="kwa">ash</span> key -<span class="num">2</span>)))
    res))

(<span class="kwa">defun</span> get-key (<span class="kwa">arr</span> offset length)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">simple-array</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>)) arr)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) offset)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) length))
  (<span class="kwa">let</span> ((<span class="kwa">key</span> <span class="num">0</span>))
    (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">64</span>) key))
    (<span class="kwa">loop</span> for i of-type (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) from offset below (+ offset length) do
         (<span class="kwa">setf</span> key (<span class="kwa">the</span> fixnum (+ (<span class="kwa">the</span> fixnum (* key <span class="num">4</span>)) (<span class="kwa">the</span> fixnum (<span class="kwa">elt</span> arr i))))))
    key))

(<span class="kwa">defun</span> to-codes-new (<span class="kwa">sequence</span> length)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">simple-array</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>)) sequence)
           (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) length)
           )
  (<span class="kwa">let</span> ((<span class="kwa">result</span> (<span class="kwa">make-array</span> length :element-type &apos;(<span class="kwa">unsigned-byte</span> <span class="num">8</span>))))
    (<span class="kwa">loop</span> for i of-type (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) from <span class="num">0</span> below length do
         (<span class="kwa">setf</span> (<span class="kwa">elt</span> result i) (<span class="kwa">elt</span> CODES (<span class="kwa">logand</span> (<span class="kwa">elt</span> sequence i) #x7))))
    result))

(<span class="kwa">defun</span> read-in-data-new (<span class="kwa">pistream</span>)
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">let</span> ((<span class="kwa">bytes</span> (<span class="kwa">make-array</span> <span class="num">1048576</span> :element-type &apos;(<span class="kwa">unsigned-byte</span> <span class="num">8</span>)))
        (<span class="kwa">position</span> <span class="num">0</span>))
    (<span class="kwa">declare</span> (<span class="kwa">type</span> (<span class="kwa">simple-array</span> (<span class="kwa">unsigned-byte</span> <span class="num">8</span>)) bytes)
             (<span class="kwa">type</span> (<span class="kwa">unsigned-byte</span> <span class="num">32</span>) position))
    (<span class="kwa">with-open-stream</span>  (<span class="kwa">istream</span> pistream)
      (<span class="kwa">loop</span> for line = (<span class="kwa">read-line</span> istream nil :eof) <span class="slc">;first, get to dna sequence three</span>
         until (<span class="kwa">or</span> (<span class="kwa">string-equal</span> <span class="str">&quot;&gt;THREE&quot;</span> (<span class="kwa">subseq</span> line <span class="num">0 6</span>))  (<span class="kwa">eql</span> line :eof)))

      (<span class="kwa">loop</span> for line = (<span class="kwa">read-line</span> istream nil :eof)
         while (<span class="kwa">not</span> (<span class="kwa">or</span> (<span class="kwa">eql</span> line :eof) (<span class="kwa">eql</span> (<span class="kwa">elt</span> line <span class="num">0</span>) #\&gt;))) do
           (<span class="kwa">if</span> (&gt; (+ position (<span class="kwa">length</span> line)) (<span class="kwa">length</span> bytes)) <span class="slc">;;then we need to grow the array</span>
               (<span class="kwa">let</span> ((<span class="kwa">newbytes</span> (<span class="kwa">make-array</span> (* <span class="num">2</span> (<span class="kwa">length</span> bytes)) :element-type &apos;(<span class="kwa">unsigned-byte</span> <span class="num">8</span>))))
                 (<span class="kwa">loop</span> for i from <span class="num">0</span> below (<span class="kwa">length</span> bytes) do
                      (<span class="kwa">setf</span> (<span class="kwa">elt</span> newbytes i) (<span class="kwa">elt</span> bytes i)))
                 (<span class="kwa">setf</span> bytes newbytes)))
           (<span class="kwa">loop</span> for i from <span class="num">0</span> below (<span class="kwa">length</span> line) do
                (<span class="kwa">setf</span> (<span class="kwa">elt</span> bytes position) (<span class="kwa">char-code</span> (<span class="kwa">elt</span> line i)))
                (<span class="kwa">incf</span> position))))
           (<span class="kwa">to-codes-new</span> bytes position)))

(<span class="kwa">defconstant</span> FRAGMENT-LENGTHS (<span class="kwa">list</span> <span class="num">1 2 3 4 6 12 18</span>))
(<span class="kwa">defconstant</span> NUCLEOTIDE-FRAGMENTS (<span class="kwa">list</span> <span class="str">&quot;GGT&quot;</span> <span class="str">&quot;GGTA&quot;</span> <span class="str">&quot;GGTATT&quot;</span> <span class="str">&quot;GGTATTTTAATT&quot;</span>
                                           <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span> ))

(<span class="kwa">defun</span> get-input-stream ()
 (<span class="kwa">open</span> #p<span class="str">&quot;/dev/stdin&quot;</span> :external-format :iso-8859-1)
<span class="slc">;(open &quot;knucleotide-input-example.txt&quot;)</span>
<span class="slc">;(open &quot;fasta-small.txt&quot;  :external-format :iso-8859-1)</span>
<span class="slc">;(open &quot;fasta.txt&quot;  :external-format :iso-8859-1)</span>
)

(<span class="kwa">defun</span> main ()
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">let</span>* ((<span class="kwa">pistream</span> (<span class="kwa">get-input-stream</span>))
         (<span class="kwa">msequence</span> (<span class="kwa">read-in-data-new</span> pistream)))
    (<span class="kwa">setf</span> *my-task-list* (<span class="kwa">create-fragment-tasks</span> msequence FRAGMENT-LENGTHS))
    (<span class="kwa">my-tr-run</span> <span class="num">4</span>)
    (<span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> (<span class="kwa">write-frequencies</span> (<span class="kwa">length</span> msequence) (<span class="kwa">my-task-result</span> (<span class="kwa">elt</span> *my-task-list* <span class="num">0</span>))))
    
    (<span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> (<span class="kwa">write-frequencies</span> (<span class="kwa">-</span> (<span class="kwa">length</span> msequence) <span class="num">1</span>) (<span class="kwa">sum-two-maps</span>
                                                       (<span class="kwa">my-task-result</span> (<span class="kwa">elt</span> *my-task-list* <span class="num">1</span>))
                                                       (<span class="kwa">my-task-result</span> (<span class="kwa">elt</span> *my-task-list* <span class="num">2</span>))
                                                                  )))
    (<span class="kwa">loop</span> for nucleotide-fragment in NUCLEOTIDE-FRAGMENTS do
         (<span class="kwa">princ</span> (<span class="kwa">write-count</span> *my-task-list*  nucleotide-fragment)))
))

(<span class="kwa">in-package</span> :cl-user)

(<span class="kwa">defun</span> main ()
  (<span class="kwa">declare</span> (<span class="kwa">optimize</span> (<span class="kwa">speed</span> <span class="num">3</span>) (<span class="kwa">safety</span> <span class="num">0</span>) (<span class="kwa">debug</span> <span class="num">0</span>)))
  (<span class="kwa">knucleotide</span>::main))
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
SBCL 2.2.4


Thu, 05 May 2022 01:03:50 GMT

MAKE:
cp: 'knucleotide.sbcl' and './knucleotide.sbcl' are the same file
SBCL built with: /opt/src/sbcl-2.2.4/bin/sbcl --userinit /dev/null --batch --eval '(load &quot;knucleotide.sbcl_compile&quot;)'
### START knucleotide.sbcl_compile
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (require :sb-concurrency)      (load (compile-file &quot;knucleotide.sbcl&quot; ))) (save-lisp-and-die &quot;sbcl.core&quot; :purify t)
### END knucleotide.sbcl_compile

; compiling file &quot;/home/dunham/all-benchmarksgame/benchmarksgame_i53330/knucleotide/tmp/knucleotide.sbcl&quot; (written 26 APR 2018 12:48:18 PM):

; file: /home/dunham/all-benchmarksgame/benchmarksgame_i53330/knucleotide/tmp/knucleotide.sbcl
; in: DEFUN MY-TR-RUN
;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* KNUCLEOTIDE::TASKINDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (FUNCALL (KNUCLEOTIDE::MY-TASK-MYLAMBDA KNUCLEOTIDE::THETASK))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; in: DEFUN WRITE-FREQUENCIES
;     (SORT KNUCLEOTIDE::FREQ
;           (LAMBDA (KNUCLEOTIDE::X KNUCLEOTIDE::Y)
;             (&gt; (CDR KNUCLEOTIDE::X) (CDR KNUCLEOTIDE::Y))))
; --&gt; BLOCK LET SB-IMPL::SEQ-DISPATCH IF LET SB-IMPL::STABLE-SORT-LIST BLOCK 
; --&gt; LABELS SB-IMPL::MERGE* BLOCK VALUES SB-IMPL::MERGE-LISTS* 
; ==&gt;
;   SB-IMPL::TEST
; 
; note: could not stack allocate SB-IMPL::TEST in:
;        (SORT FREQ (LAMBDA (X Y) (&gt; (CDR X) (CDR Y))))

; ==&gt;
;   SB-IMPL::KEY
; 
; note: could not stack allocate SB-IMPL::KEY in:
;        (SORT FREQ (LAMBDA (X Y) (&gt; (CDR X) (CDR Y))))

; --&gt; BLOCK LET SB-IMPL::SEQ-DISPATCH IF LET SB-IMPL::STABLE-SORT-LIST 
; ==&gt;
;   SB-IMPL::PREDICATE-FUN
; 
; note: could not stack allocate SB-IMPL::PREDICATE-FUN in:
;        (SORT FREQ (LAMBDA (X Y) (&gt; (CDR X) (CDR Y))))

;     (MAKE-ARRAY
;      (HASH-TABLE-COUNT (KNUCLEOTIDE::RESULT-OUTMAP KNUCLEOTIDE::FREQUENCIES))
;      :FILL-POINTER 0 :ELEMENT-TYPE 'CONS)
; 
; caught STYLE-WARNING:
;   The default initial element 0 is not a CONS.
;   See also:
;     The ANSI Standard, Function MAKE-ARRAY
;     The ANSI Standard, Function UPGRADED-ARRAY-ELEMENT-TYPE

;     (SORT KNUCLEOTIDE::FREQ
;           (LAMBDA (KNUCLEOTIDE::X KNUCLEOTIDE::Y)
;             (&gt; (CDR KNUCLEOTIDE::X) (CDR KNUCLEOTIDE::Y))))
; --&gt; LOCALLY SB-C::%FUNCALL 
; ==&gt;
;   SB-IMPL::PREDICATE
; 
; note: could not stack allocate: (SORT FREQ (LAMBDA (X Y) (&gt; (CDR X) (CDR Y))))

;     (&gt; (CDR KNUCLEOTIDE::X) (CDR KNUCLEOTIDE::Y))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
;   The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
;   The second argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (* KNUCLEOTIDE::VALUE 100.0)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (/ (* KNUCLEOTIDE::VALUE 100.0) KNUCLEOTIDE::TOTALCOUNT)
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a (OR
;                                                               (COMPLEX
;                                                                SINGLE-FLOAT)
;                                                               (COMPLEX
;                                                                DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a (COMPLEX
;                                                               DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a (COMPLEX
;                                                               SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a (COMPLEX
;                                                               DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                               (COMPLEX DOUBLE-FLOAT)), not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).

;     (* KNUCLEOTIDE::VALUE 100.0)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES
;                        (OR FLOAT (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT))
;                        &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES
;                        (OR FLOAT (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT))
;                        &amp;OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &amp;REST T).

;     (/ (* KNUCLEOTIDE::VALUE 100.0) KNUCLEOTIDE::TOTALCOUNT)
; 
; note: forced to do full call
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                                   (COMPLEX DOUBLE-FLOAT)), not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES
;                        (OR FLOAT (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT))
;                        &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT &amp;REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a (OR FLOAT (COMPLEX SINGLE-FLOAT)
;                                   (COMPLEX DOUBLE-FLOAT)), not a (COMPLEX
;                                                                   SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES
;                        (OR FLOAT (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT))
;                        &amp;OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &amp;REST T).
;       etc.

;     (&gt; (CDR KNUCLEOTIDE::X) (CDR KNUCLEOTIDE::Y))
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFUN WRITE-COUNT
;     (MAP '(VECTOR (UNSIGNED-BYTE 8)) #'CHAR-CODE KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LOOP KNUCLEOTIDE::FOR KNUCLEOTIDE::TASK KNUCLEOTIDE::ACROSS KNUCLEOTIDE::TASKS
;           KNUCLEOTIDE::FOR KNUCLEOTIDE::RESULT = (KNUCLEOTIDE::MY-TASK-RESULT
;                                                   KNUCLEOTIDE::TASK)
;           DO (IF (EQL (KNUCLEOTIDE::RESULT-KEYLENGTH KNUCLEOTIDE::RESULT)
;                       (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT))
;                  (SETF COUNT (+ COUNT #))))
; --&gt; LET LET LET TAGBODY SB-LOOP::LOOP-DESETQ SETQ THE AREF 
; ==&gt;
;   1
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (+ COUNT
;        (GETHASH KNUCLEOTIDE::K (KNUCLEOTIDE::RESULT-OUTMAP KNUCLEOTIDE::RESULT)
;                 0))
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
;   The second argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                              (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   open-code float conversion in mixed numeric operation
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFUN READ-IN-DATA-NEW
;     (SUBSEQ KNUCLEOTIDE::LINE 0 6)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (ELT KNUCLEOTIDE::LINE 0)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (LENGTH KNUCLEOTIDE::LINE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::LINE KNUCLEOTIDE::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

; in: DEFUN MAIN
;     (LENGTH KNUCLEOTIDE::MSEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 0)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (LENGTH KNUCLEOTIDE::MSEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
;   printed 54 notes


; wrote /home/dunham/all-benchmarksgame/benchmarksgame_i53330/knucleotide/tmp/knucleotide.fasl
; compilation finished in 0:00:00.192
### START knucleotide.sbcl_run
(main) (quit)
### END knucleotide.sbcl_run


2.70s to complete and log all make actions

COMMAND LINE:
/opt/src/sbcl-2.2.4/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load knucleotide.sbcl_run 0 &lt; knucleotide-input25000000.txt

PROGRAM OUTPUT:
A 30.295
T 30.151
C 19.800
G 19.754

AA 9.177
TA 9.132
AT 9.131
TT 9.091
CA 6.002
AC 6.001
AG 5.987
GA 5.984
CT 5.971
TC 5.971
GT 5.957
TG 5.956
CC 3.917
GC 3.911
CG 3.909
GG 3.902

1471758	GGT
446535	GGTA
47336	GGTATT
893	GGTATTTTAATT
893	GGTATTTTAATTTATAGT
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

