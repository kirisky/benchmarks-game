<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>k-nucleotide Ada 2012 GNAT&nbsp;#2 program (Benchmarks Game) </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The&nbsp;<small>Computer&nbsp;Language</small><br/>22.05 Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>k-nucleotide Ada 2012 GNAT&nbsp;#2 program</h1>
    <aside>
      <p><a href="../description/knucleotide.html#knucleotide">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">--  The Computer Language Benchmarks Game</span>
<span class="slc">--  https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">--</span>
<span class="slc">--  Contributed by Martin Krischik</span>
<span class="slc">--  Modified by Georg Bauhaus and Jonathan Parker</span>

<span class="kwa">pragma</span> Restrictions (No_Abort_Statements);
<span class="kwa">pragma</span> Restrictions (Max_Asynchronous_Select_Nesting =&gt; <span class="num">0</span>);

<span class="kwa">with</span> Ada.Characters.Latin_1;
<span class="kwa">with</span> Ada.Integer_Text_IO;
<span class="kwa">with</span> Ada.Float_Text_IO;
<span class="kwa">with</span> Ada.Text_IO;
<span class="kwa">with</span> Ada.Exceptions;

<span class="kwa">with</span> String_Fragments;
<span class="kwa">with</span> Data_Input;
<span class="kwa">with</span> GNAT.Heap_Sort_G;
<span class="kwa">with</span> GNAT.HTable;

<span class="kwa">procedure</span> KNucleotide <span class="kwa">is</span>

   <span class="kwa">subtype</span> Fragment_Lengths <span class="kwa">is</span> <span class="kwb">Integer</span> <span class="kwa">range</span> <span class="num">1</span> .. <span class="num">18</span>;

   <span class="slc">--  Data read as single String:</span>

   Buffer : <span class="kwa">constant</span> <span class="kwb">String</span> := Data_Input.Read;

   <span class="slc">--  Calculate and write data - either a percentage for all fragments found</span>
   <span class="slc">--  or - when Nucleotide_Fragment is given - the count for that fragment.</span>

   <span class="kwa">generic</span>
      <span class="kwa">with package</span> Fragments <span class="kwa">is new</span> String_Fragments(&lt;&gt;);
   <span class="kwa">package</span> Work <span class="kwa">is</span>

      <span class="kwa">procedure</span> Write
        (Nucleotide_Length   : <span class="kwa">in</span> Fragment_Lengths;
         Nucleotide_Fragment : <span class="kwa">in</span> Fragments.Fragment := Fragments.Null_Fragment);

      <span class="kwa">task</span> Writer <span class="kwa">is</span>
         <span class="slc">--</span>
         <span class="slc">--  Performs `Write` calls</span>
         <span class="slc">--</span>
         <span class="kwa">pragma</span> Storage_Size (<span class="num">2</span>**<span class="num">24</span>);

         <span class="kwa">entry</span> Set (Nucleotide_Length   : <span class="kwa">in</span> Fragment_Lengths;
                    Nucleotide_Fragment : <span class="kwa">in</span> Fragments.Fragment := Fragments.Null_Fragment);
      <span class="kwa">end</span> Writer;

   <span class="kwa">end</span> Work;


   <span class="kwa">type</span> Order <span class="kwa">is array</span> (Fragment_Lengths) <span class="kwa">of</span> <span class="kwb">Boolean</span>;

   <span class="kwa">protected</span> Printer <span class="kwa">is</span>
      <span class="slc">--</span>
      <span class="slc">--  Serializes access to output</span>
      <span class="slc">--</span>
      <span class="kwa">entry</span> Seize (Fragment_Lengths);
      <span class="kwa">procedure</span> Release (L : Fragment_Lengths);

   <span class="kwa">private</span>
      Done : Order :=
        (<span class="num">1</span> | <span class="num">2</span> | <span class="num">3</span> | <span class="num">4</span> | <span class="num">6</span> | <span class="num">12</span> | <span class="num">18</span> =&gt; <span class="kwd">False</span>,
         <span class="kwa">others</span> =&gt; <span class="kwd">True</span>);
   <span class="kwa">end</span> Printer;

   <span class="kwa">protected body</span> Printer <span class="kwa">is</span>

      <span class="slc">--  Use families&apos; entry indexes to find that output of preceding</span>
      <span class="slc">--  `Write`s has already been produced thus ordering the tasks&apos;s results.</span>

      <span class="kwa">entry</span> Seize (<span class="kwa">for</span> L <span class="kwa">in</span> Fragment_Lengths)
      <span class="kwa">when</span> Done (<span class="num">1</span> .. Fragment_Lengths<span class="kwd">&apos;Pred</span>(L)) = (<span class="num">1</span> .. Fragment_Lengths<span class="kwd">&apos;Pred</span>(L) =&gt; <span class="kwd">True</span>) <span class="kwa">is</span>
      <span class="kwa">begin</span>
         <span class="kwa">null</span>;
      <span class="kwa">end</span> Seize;

      <span class="kwa">procedure</span> Release (L : Fragment_Lengths) <span class="kwa">is</span>
      <span class="kwa">begin</span>
         Done (L) := <span class="kwd">True</span>;
      <span class="kwa">end</span> Release;

   <span class="kwa">end</span> Printer;

   <span class="kwa">package body</span> Work <span class="kwa">is</span>

      <span class="slc">---------------------</span>
      <span class="slc">-- procedure Write --</span>
      <span class="slc">---------------------</span>

      <span class="slc">--  Procedure KNucleotide&apos;s tasks call Write in order to calculate and</span>
      <span class="slc">--  write data - either a percentage for all fragments found or - when</span>
      <span class="slc">--  Nucleotide_Fragment is given - the count for that fragment.</span>
      <span class="slc">--</span>
      <span class="kwa">procedure</span> Write
        (Nucleotide_Length   : <span class="kwa">in</span> Fragment_Lengths;
         Nucleotide_Fragment : <span class="kwa">in</span> Fragments.Fragment := Fragments.Null_Fragment)
      <span class="kwa">is</span>
         <span class="kwa">use</span> Fragments;

         <span class="slc">--  Package is an interface to GNAT&apos;s simple hash table: GNAT.HTable.</span>
         <span class="slc">--  The package calculates nucleotide Fragment_Lengths and keeps the</span>
         <span class="slc">--  result inside a hash table as requested by the shootout rules.</span>

         <span class="kwa">package</span> Calculator <span class="kwa">is</span>

            <span class="slc">--  Elements used to store inside hash table:</span>

            <span class="kwa">type</span> Element_Type <span class="kwa">is private</span>;
            <span class="kwa">type</span> Element_Access <span class="kwa">is access</span> Element_Type;
            <span class="kwa">for</span> Element_Access<span class="kwd">&apos;Storage_Size</span> <span class="kwa">use</span> <span class="num">16</span>#<span class="num">60</span>_00_01#;


<span class="slc">--  Calculate frequency of occurrence of the nucleotides:</span>

            <span class="kwa">procedure</span> Get_Frequencies (Length : Fragment_Lengths);

            <span class="slc">--  Get the count for the given nucleotide fragment:</span>

            <span class="kwa">function</span> Number_Counted (Nucleotide_Fragment : Fragment) <span class="kwa">return</span> <span class="kwb">Natural</span>;

            <span class="slc">--  Start to iterate over all elements of hash table:</span>

            <span class="kwa">function</span> Get_First <span class="kwa">return</span> Element_Access;

            <span class="slc">--  Continue itereation over the hash table:</span>

            <span class="kwa">function</span> Get_Next <span class="kwa">return</span> Element_Access;

            <span class="slc">--  Key and value when computed:</span>

            <span class="kwa">function</span> Count_Of (Element : <span class="kwa">not null</span> Element_Access) <span class="kwa">return</span> <span class="kwb">Natural</span>;
            <span class="kwa">function</span> Fragment_Of (Element : <span class="kwa">not null</span> Element_Access) <span class="kwa">return</span> Fragment;

            <span class="slc">--  Get total count over all elements - as well as the count of</span>
            <span class="slc">--  elements:</span>

            <span class="kwa">procedure</span> Get_Totals (Total : <span class="kwa">out</span> <span class="kwb">Natural</span>; Count : <span class="kwa">out</span> <span class="kwb">Natural</span>);

         <span class="kwa">private</span>
            <span class="kwa">pragma</span> Inline (Count_of, Fragment_Of);

            <span class="kwa">type</span> Element_Type <span class="kwa">is record</span>
               Count : <span class="kwb">Natural</span>        := <span class="num">0</span>;
               Key   : Fragment       := Fragments.Null_Fragment;
               Next  : Element_Access := <span class="kwa">null</span>;
            <span class="kwa">end record</span>;
         <span class="kwa">end</span> Calculator;

         <span class="kwa">package body</span> Calculator <span class="kwa">is</span>

            Log_Table_Size : <span class="kwa">constant</span> <span class="kwb">Natural</span> := <span class="kwb">Natural</span><span class="kwd">&apos;Min</span> (Fragment<span class="kwd">&apos;Last</span>*<span class="num">2</span>+<span class="num">4</span>, <span class="num">17</span>);
            Table_Size     : <span class="kwa">constant</span> <span class="kwb">Natural</span> := <span class="num">2</span> ** Log_Table_Size;

            <span class="kwa">subtype</span> Hash_Type <span class="kwa">is</span> <span class="kwb">Natural</span> <span class="kwa">range</span> <span class="num">0</span> .. Table_Size - <span class="num">1</span>;

            <span class="kwa">function</span> Hash (Key : Fragment) <span class="kwa">return</span> Hash_Type;
            <span class="kwa">procedure</span> Set_Next (E : Element_Access; Next : Element_Access);
            <span class="kwa">function</span> Next (E : Element_Access) <span class="kwa">return</span> Element_Access;
            <span class="kwa">function</span> Get_Key (E : <span class="kwa">not null</span> Element_Access) <span class="kwa">return</span> Fragment;

            <span class="kwa">pragma</span> Inline (Hash, Set_Next, Next, Get_Key);

            <span class="kwa">package</span> Table <span class="kwa">is new</span> GNAT.HTable.Static_HTable
              (Header_Num =&gt; Hash_Type,
               Element    =&gt; Element_Type,
               Elmt_Ptr   =&gt; Element_Access,
               Null_Ptr   =&gt; <span class="kwa">null</span>,
               Key        =&gt; Fragment,
               Hash       =&gt; Hash,
               Equal      =&gt; Fragments.<span class="str">&quot;=&quot;</span>,
               Set_Next   =&gt; Set_Next,
               Next       =&gt; Next,
               Get_Key    =&gt; Get_Key);


            <span class="kwa">function</span> Hash (Key : Fragment) <span class="kwa">return</span> Hash_Type <span class="kwa">is</span>
               <span class="kwa">pragma</span> Assert (Hash_Type<span class="kwd">&apos;First</span> = <span class="num">0</span>);
               <span class="kwa">pragma</span> Assert (Hash_Type<span class="kwd">&apos;Last</span>  = <span class="num">2</span>**Log_Table_Size - <span class="num">1</span>);
               <span class="kwa">type</span> Uns_32 <span class="kwa">is mod</span> <span class="num">2</span>**<span class="num">32</span>;
               H : Uns_32 := <span class="kwb">Character</span><span class="kwd">&apos;Pos</span> (Key (Key<span class="kwd">&apos;First</span>));
            <span class="kwa">begin</span>
               <span class="kwa">for</span> J <span class="kwa">in</span> Key<span class="kwd">&apos;First</span> + <span class="num">1</span> .. Key<span class="kwd">&apos;Last</span> <span class="kwa">loop</span>
                  H := <span class="kwb">Character</span><span class="kwd">&apos;Pos</span> (Key (J)) + H * <span class="num">2</span>**<span class="num">3</span> + H;
               <span class="kwa">end loop</span>;
               H := (H / <span class="num">2</span>**Log_Table_Size) <span class="kwa">xor</span> H;
               <span class="kwa">return</span> Hash_Type<span class="kwd">&apos;Base</span> (H <span class="kwa">mod</span> <span class="num">2</span>**Log_Table_Size);
            <span class="kwa">end</span> Hash;


            <span class="kwa">procedure</span> Get_Frequencies (Length : Fragment_Lengths) <span class="kwa">is</span>
            <span class="kwa">begin</span>
               <span class="kwa">for</span> I <span class="kwa">in</span>  <span class="num">1</span> .. Buffer<span class="kwd">&apos;Last</span> - Length + <span class="num">1</span> <span class="kwa">loop</span>
                  <span class="kwa">declare</span>
                     Key : <span class="kwb">String</span> <span class="kwa">renames</span> Buffer(I .. I + Length - <span class="num">1</span>);
                     Element : <span class="kwa">constant</span> Element_Access := Table.Get (Key);
                  <span class="kwa">begin</span>
                     <span class="kwa">if</span> Element /= <span class="kwa">null then</span>
                        Element.<span class="kwa">all</span>.Count := <span class="kwb">Natural</span><span class="kwd">&apos;Succ</span> (Element.<span class="kwa">all</span>.Count);
                     <span class="kwa">else</span>
                        Table.Set (<span class="kwa">new</span> Element_Type<span class="str">&apos;(Count =&gt; 1,</span>
<span class="str">                                                     Key =&gt; Key,</span>
<span class="str">                                                     Next =&gt; null));</span>
<span class="str">                     end if;</span>
<span class="str">                  end;</span>
<span class="str">               end loop;</span>
<span class="str">               return;</span>
<span class="str">            end Get_Frequencies;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Count_Of (Element : not null Element_Access) return Natural is</span>
<span class="str">            begin</span>
<span class="str">               return Element.all.Count;</span>
<span class="str">            end Count_Of;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Number_Counted (Nucleotide_Fragment : Fragment) return Natural is</span>
<span class="str">               The_Element : constant Element_Access := Table.Get (Nucleotide_Fragment);</span>
<span class="str">            begin</span>
<span class="str">               if The_Element /= null then</span>
<span class="str">                  return The_Element.all.Count;</span>
<span class="str">               else</span>
<span class="str">                  return 0;</span>
<span class="str">               end if;</span>
<span class="str">            end Number_Counted;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Get_First return Element_Access is</span>
<span class="str">            begin</span>
<span class="str">               return Table.Get_First;</span>
<span class="str">            end Get_First;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Get_Key (E : not null Element_Access) return Fragment is</span>
<span class="str">            begin</span>
<span class="str">               return E.all.Key;</span>
<span class="str">            end Get_Key;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Get_Next return Element_Access is</span>
<span class="str">            begin</span>
<span class="str">               return Table.Get_Next;</span>
<span class="str">            end Get_Next;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            procedure Get_Totals (Total : out Natural; Count : out Natural) is</span>
<span class="str">               The_Element : Element_Access := Table.Get_First;</span>
<span class="str">            begin</span>
<span class="str">               Total := 0;</span>
<span class="str">               Count := 0;</span>
<span class="str">               while The_Element /= null loop</span>
<span class="str">                  Total       := Total + The_Element.all.Count;</span>
<span class="str">                  Count       := Count + 1;</span>
<span class="str">                  The_Element := Table.Get_Next;</span>
<span class="str">               end loop;</span>
<span class="str">            end Get_Totals;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">            function Fragment_Of (Element : not null Element_Access) return Fragment is</span>
<span class="str">            begin</span>
<span class="str">               return Element.all.Key;</span>
<span class="str">            end Fragment_Of;</span>
<span class="str"></span>
<span class="str">            function Next (E : Element_Access) return Element_Access is</span>
<span class="str">            begin</span>
<span class="str">               return E.all.Next;</span>
<span class="str">            end Next;</span>
<span class="str"></span>
<span class="str">            procedure Set_Next (E : Element_Access; Next : Element_Access) is</span>
<span class="str">            begin</span>
<span class="str">               E.all.Next := Next;</span>
<span class="str">            end Set_Next;</span>
<span class="str"></span>
<span class="str">         end Calculator;</span>
<span class="str"></span>
<span class="str">      begin --  Write</span>
<span class="str"></span>
<span class="str">         Calculator.Get_Frequencies (Nucleotide_Length);</span>
<span class="str"></span>
<span class="str">         if Nucleotide_Fragment = Fragments.Null_Fragment then</span>
<span class="str">            Calculate_Total : declare</span>
<span class="str">               Num_Table_Entries : Natural;</span>
<span class="str">               Sum_Of_Counts     : Natural;</span>
<span class="str">            begin</span>
<span class="str">               Calculator.Get_Totals</span>
<span class="str">                 (Total =&gt; Sum_Of_Counts,</span>
<span class="str">                  Count =&gt; Num_Table_Entries);</span>
<span class="str"></span>
<span class="str">               Get_Sort_Put : declare</span>
<span class="str">                  Data : array (0 .. Num_Table_Entries) of Calculator.Element_Access;</span>
<span class="str"></span>
<span class="str">                  --  heap sort subprograms</span>
<span class="str">                  procedure Move (From : Natural; To : Natural);</span>
<span class="str">                  function Less_Then (Op1, Op2 : Natural) return Boolean;</span>
<span class="str"></span>
<span class="str">                  pragma Inline (Move, Less_Then);</span>
<span class="str"></span>
<span class="str">                  function Less_Then (Op1, Op2 : Natural) return Boolean is</span>
<span class="str">                  begin</span>
<span class="str">                     return</span>
<span class="str">                       Calculator.Count_Of (Data (Op1))</span>
<span class="str">                       &gt;</span>
<span class="str">                       Calculator.Count_Of (Data (Op2));</span>
<span class="str">                  end Less_Then;</span>
<span class="str"></span>
<span class="str">                  procedure Move (From : Natural; To : Natural) is</span>
<span class="str">                  begin</span>
<span class="str">                     Data (To) := Data (From);</span>
<span class="str">                  end Move;</span>
<span class="str"></span>
<span class="str">                  package Heap_Sort is new GNAT.Heap_Sort_G</span>
<span class="str">                    (Move =&gt; Move,</span>
<span class="str">                     Lt   =&gt; Less_Then);</span>
<span class="str"></span>
<span class="str">               begin  -- Get_Sort_Put</span>
<span class="str">                  Data (0) := null;</span>
<span class="str">                  Data (1) := Calculator.Get_First;</span>
<span class="str"></span>
<span class="str">                  for I in  2 .. Data&apos;Last loop</span>
<span class="str">                     Data (I) := Calculator.Get_Next;</span>
<span class="str">                  end loop;</span>
<span class="str"></span>
<span class="str">                  Heap_Sort.Sort (Data&apos;Last);</span>
<span class="str"></span>
<span class="str">                  Printer.Seize (Nucleotide_Length);</span>
<span class="str">                  for I in  1 .. Data&apos;Last loop</span>
<span class="str">                     Ada.Text_IO.Put (Calculator.Fragment_Of (Data (I)) &amp; &apos;</span> <span class="str">&apos;);</span>
<span class="str">                     Ada.Float_Text_IO.Put</span>
<span class="str">                       (Item =&gt; (100.0</span>
<span class="str">                                   * Float (Calculator.Count_Of (Data (I)))</span>
<span class="str">                                   / Float (Sum_Of_Counts)),</span>
<span class="str">                        Fore =&gt; 1,</span>
<span class="str">                        Aft  =&gt; 3,</span>
<span class="str">                        Exp  =&gt; 0);</span>
<span class="str">                     Ada.Text_IO.New_Line;</span>
<span class="str">                  end loop;</span>
<span class="str">                  Ada.Text_IO.New_Line;</span>
<span class="str">                  Printer.Release (Nucleotide_Length);</span>
<span class="str">               end Get_Sort_Put;</span>
<span class="str">            end Calculate_Total;</span>
<span class="str">         else</span>
<span class="str">            Printer.Seize (Nucleotide_Length);</span>
<span class="str">            Ada.Integer_Text_IO.Put</span>
<span class="str">              (Item =&gt; Calculator.Number_Counted (Nucleotide_Fragment),</span>
<span class="str">               Width =&gt; 1);</span>
<span class="str">            Ada.Text_IO.Put (Ada.Characters.Latin_1.HT);</span>
<span class="str">            Ada.Text_IO.Put_Line (Nucleotide_Fragment);</span>
<span class="str">            Printer.Release (Nucleotide_Length);</span>
<span class="str">         end if;</span>
<span class="str">      end Write;</span>
<span class="str"></span>
<span class="str">      task body Writer is</span>
<span class="str">         Current_Length   : Fragment_Lengths;</span>
<span class="str">         Current_Fragment : Fragments.Fragment;</span>
<span class="str"></span>
<span class="str">         use Fragments;</span>
<span class="str">      begin</span>
<span class="str">         loop</span>
<span class="str">            --</span>
<span class="str">            --  perform a `Write` with parameters `Set` or terminate</span>
<span class="str">            --</span>
<span class="str">            select</span>
<span class="str">               accept Set (Nucleotide_Length   : in Fragment_Lengths;</span>
<span class="str">                           Nucleotide_Fragment : in Fragment := Null_Fragment)</span>
<span class="str">               do</span>
<span class="str">                  Current_Length   := Nucleotide_Length;</span>
<span class="str">                  Current_Fragment := Nucleotide_Fragment;</span>
<span class="str">               end Set;</span>
<span class="str">               Write (Current_Length, Current_Fragment);</span>
<span class="str">            or</span>
<span class="str">               terminate;</span>
<span class="str">            end select;</span>
<span class="str">         end loop;</span>
<span class="str">      exception</span>
<span class="str">         when E : others =&gt;</span>
<span class="str">            Ada.Text_IO.Put_Line(Ada.Text_IO.Current_Error,</span>
<span class="str">              Ada.Exceptions.Exception_Information(E));</span>
<span class="str">      end Writer;</span>
<span class="str"></span>
<span class="str">   end Work;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">   package Fragments_1 is new String_Fragments (1);</span>
<span class="str">   package Fragments_2 is new String_Fragments (2);</span>
<span class="str">   package Fragments_3 is new String_Fragments (3);</span>
<span class="str">   package Fragments_4 is new String_Fragments (4);</span>
<span class="str">   package Fragments_6 is new String_Fragments (6);</span>
<span class="str">   package Fragments_12 is new String_Fragments (12);</span>
<span class="str">   package Fragments_18 is new String_Fragments (18);</span>
<span class="str"></span>
<span class="str">   --  List of fragments to be analyzed for this test:</span>
<span class="str"></span>
<span class="str">   Fragment_3  : constant Fragments_3.Fragment := Fragments_3.To_Fragment (&quot;GGT&quot;);</span>
<span class="str">   Fragment_4  : constant Fragments_4.Fragment := Fragments_4.To_Fragment (&quot;GGTA&quot;);</span>
<span class="str">   Fragment_6  : constant Fragments_6.Fragment := Fragments_6.To_Fragment (&quot;GGTATT&quot;);</span>
<span class="str">   Fragment_12 : constant Fragments_12.Fragment := Fragments_12.To_Fragment (&quot;GGTATTTTAATT&quot;);</span>
<span class="str">   Fragment_18 : constant Fragments_18.Fragment := Fragments_18.To_Fragment (&quot;GGTATTTTAATTTATAGT&quot;);</span>
<span class="str"></span>
<span class="str">   package Work_On_1 is new Work (Fragments_1);</span>
<span class="str">   package Work_On_2 is new Work (Fragments_2);</span>
<span class="str">   package Work_On_3 is new Work (Fragments_3);</span>
<span class="str">   package Work_On_4 is new Work (Fragments_4);</span>
<span class="str">   package Work_On_6 is new Work (Fragments_6);</span>
<span class="str">   package Work_On_12 is new Work (Fragments_12);</span>
<span class="str">   package Work_On_18 is new Work (Fragments_18);</span>
<span class="str"></span>
<span class="str">begin</span>
<span class="str">   Work_On_1.Writer.Set (1);</span>
<span class="str">   Work_On_12.Writer.Set (Fragment_12&apos;Length, Fragment_12);</span>
<span class="str">   Work_On_18.Writer.Set (Fragment_18&apos;Length, Fragment_18);</span>
<span class="str">   Work_On_6.Writer.Set (Fragment_6&apos;Length, Fragment_6);</span>
<span class="str">   Work_On_2.Writer.Set (2);</span>
<span class="str">   Work_On_4.Writer.Set (Fragment_4&apos;Length, Fragment_4);</span>
<span class="str">   Work_On_3.Writer.Set (Fragment_3&apos;Length, Fragment_3);</span>
<span class="str">end KNucleotide;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str"></span>
<span class="str">generic</span>
<span class="str">   Max_String_Length : Positive;</span>
<span class="str">package String_Fragments is</span>
<span class="str"></span>
<span class="str">   subtype Fragment is String (1 .. Max_String_Length);</span>
<span class="str"></span>
<span class="str">   function To_Fragment (Source : String) return Fragment;</span>
<span class="str">   function Null_Fragment return Fragment;</span>
<span class="str">   function &quot;=&quot; (Left, Right: Fragment) return Boolean;</span>
<span class="str"></span>
<span class="str">end String_Fragments;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">with Ada.Unchecked_Conversion;</span>
<span class="str"></span>
<span class="str">package body String_Fragments is</span>
<span class="str"></span>
<span class="str">   Bytes_Per_Word : constant := 4;</span>
<span class="str">   type Uns is mod 2**(8 * Bytes_Per_Word);</span>
<span class="str">   for Uns&apos;Size use 8 * Bytes_Per_Word;</span>
<span class="str">   subtype Str is String (1 .. Bytes_Per_Word);</span>
<span class="str"></span>
<span class="str">   function Null_Fragment return Fragment is</span>
<span class="str">   begin</span>
<span class="str">      return Fragment&apos;</span>(<span class="num">1</span> .. Max_String_Length =&gt; <span class="str">&apos;*&apos;</span>);
   <span class="kwa">end</span> Null_Fragment;


   <span class="kwa">function</span> To_Uns <span class="kwa">is new</span> Ada.Unchecked_Conversion (Str, Uns);

   <span class="kwa">function</span> <span class="str">&quot;=&quot;</span> (Left, Right: Fragment) <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span>
      Strt : <span class="kwb">Integer</span> := <span class="num">1</span>;
      Fnsh : <span class="kwb">Integer</span> := Bytes_Per_Word;
      Last : <span class="kwa">constant</span> <span class="kwb">Integer</span> := Left<span class="kwd">&apos;Last</span>;
   <span class="kwa">begin</span>
      <span class="kwa">if</span> Last /= Right<span class="kwd">&apos;Last</span> <span class="kwa">then</span>
         <span class="kwa">return</span> <span class="kwd">False</span>;
      <span class="kwa">end if</span>;

      <span class="kwa">loop</span>
         <span class="kwa">exit when</span> Fnsh &gt; Last;
         <span class="kwa">if</span> To_Uns (Left(Strt..Fnsh)) /= To_Uns (Right(Strt..Fnsh)) <span class="kwa">then</span>
            <span class="kwa">return</span> <span class="kwd">False</span>;
         <span class="kwa">end if</span>;
         Strt := Strt + Bytes_Per_Word;
         Fnsh := Fnsh + Bytes_Per_Word;
      <span class="kwa">end loop</span>;

      <span class="kwa">for</span> I <span class="kwa">in</span> Strt .. Last <span class="kwa">loop</span>
         <span class="kwa">if</span> Left(I) /= Right(I) <span class="kwa">then</span>
            <span class="kwa">return</span> <span class="kwd">False</span>;
         <span class="kwa">end if</span>;
      <span class="kwa">end loop</span>;
      <span class="kwa">return</span> <span class="kwd">True</span>;
   <span class="kwa">end</span> <span class="str">&quot;=&quot;</span>;


   <span class="kwa">function</span> To_Fragment (Source : <span class="kwb">String</span>) <span class="kwa">return</span> Fragment <span class="kwa">is</span>
      Result : Fragment;
   <span class="kwa">begin</span>
      <span class="kwa">if</span> Source<span class="kwd">&apos;Length</span> /= Max_String_Length <span class="kwa">then</span>
         <span class="kwa">raise</span> Constraint_Error;
      <span class="kwa">end if</span>;
      Result (<span class="num">1</span> .. Source<span class="kwd">&apos;Length</span>) := Source;
      <span class="kwa">return</span> Result;
   <span class="kwa">end</span> To_Fragment;

<span class="kwa">end</span> String_Fragments;


<span class="slc">----------------</span>
<span class="slc">-- data input --</span>
<span class="slc">----------------</span>

<span class="kwa">package</span> Data_Input <span class="kwa">is</span>

   <span class="slc">--  Read data from Standard_Input and return section THREE as String:</span>

   <span class="kwa">function</span> Read <span class="kwa">return</span> <span class="kwb">String</span>;

<span class="kwa">end</span> Data_Input;

<span class="kwa">with</span> Ada.Strings.Maps.Constants;
<span class="kwa">with</span> Ada.IO_Exceptions;
<span class="kwa">with</span> Ada.Strings.Unbounded;
<span class="kwa">with</span> Line_IO;
<span class="kwa">with</span> Ada.Unchecked_Deallocation;

<span class="kwa">package body</span> Data_Input <span class="kwa">is</span>

   <span class="kwa">use</span> Ada.Strings;
   UnixLF : <span class="kwa">constant</span> <span class="kwb">String</span> := <span class="kwb">String</span><span class="str">&apos;(1 =&gt; ASCII.LF);</span>
<span class="str">   package LIO is new Line_IO (UnixLF);</span>
<span class="str"></span>
<span class="str">   Data_Buffer : Unbounded.Unbounded_String := Unbounded.Null_Unbounded_String;</span>
<span class="str"></span>
<span class="str">   Section_Marker : constant Character := &apos;</span>&gt;<span class="str">&apos;;</span>
<span class="str">   Section        : constant String    := Section_Marker &amp; &quot;THREE&quot;;</span>
<span class="str"></span>
<span class="str">   --  Read next data section - until EOF oder a line beginning with &gt; is found.</span>
<span class="str"></span>
<span class="str">   type String_Access is access String;</span>
<span class="str">   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);</span>
<span class="str"></span>
<span class="str">   procedure Read_Section is</span>
<span class="str">      Buffer     : String_Access;</span>
<span class="str">      Read_First : Natural;</span>
<span class="str">      Read_Last  : Natural;</span>
<span class="str">   begin</span>
<span class="str">      Buffer := new String (1 .. 1024 * 1024 * 16);</span>
<span class="str">      Get_Data : loop</span>
<span class="str">         Read_First := Buffer&apos;First;</span>
<span class="str">         Read_Last  := Buffer&apos;First - 1;</span>
<span class="str">         -- fill Buffer and append to Data_Buffer when filled</span>
<span class="str">         loop</span>
<span class="str">            declare</span>
<span class="str">               Line : String renames LIO.Get_Line;</span>
<span class="str">            begin</span>
<span class="str">               Read_Last := Read_First + Line&apos;Length - 1;</span>
<span class="str">               if Read_Last &gt;= Buffer&apos;Last then</span>
<span class="str">                  Unbounded.Append</span>
<span class="str">                    (Data_Buffer, New_Item =&gt; Buffer(1 .. Read_First - 1));</span>
<span class="str">                  Unbounded.Append (Data_Buffer, New_Item =&gt; Line);</span>
<span class="str">                  exit;</span>
<span class="str">               end if;</span>
<span class="str">               Buffer (Read_First .. Read_Last) := Line;</span>
<span class="str">            end;</span>
<span class="str">            exit Get_Data when Buffer (Read_First) = Section_Marker;</span>
<span class="str">            Read_First := Read_Last + 1;</span>
<span class="str">         end loop;</span>
<span class="str">      end loop Get_Data;</span>
<span class="str">      Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="str">      Free (Buffer);</span>
<span class="str">   exception</span>
<span class="str">      when Ada.IO_Exceptions.End_Error =&gt;</span>
<span class="str">         Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="str">         Free (Buffer);</span>
<span class="str">   end Read_Section;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">   --  Skip data on Standard_Input until &quot;&gt;THREE&quot; is found</span>
<span class="str"></span>
<span class="str">   procedure Skip_To_Section is</span>
<span class="str">   begin</span>
<span class="str">      loop</span>
<span class="str">         declare</span>
<span class="str">            Line : constant String := LIO.Get_Line;</span>
<span class="str">         begin</span>
<span class="str">            exit when Line(1) = Section(1)</span>
<span class="str">              and then Line(Section&apos;Range) = Section;</span>
<span class="str">         end;</span>
<span class="str">      end loop;</span>
<span class="str">   end Skip_To_Section;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">   function Read return String is</span>
<span class="str">   begin</span>
<span class="str">      Skip_To_Section;</span>
<span class="str">      Read_Section;</span>
<span class="str"></span>
<span class="str">      Unbounded.Translate</span>
<span class="str">        (Source =&gt; Data_Buffer,</span>
<span class="str">         Mapping =&gt; Maps.Constants.Upper_Case_Map);</span>
<span class="str"></span>
<span class="str">      return Unbounded.To_String (Data_Buffer);</span>
<span class="str">   end Read;</span>
<span class="str"></span>
<span class="str">end Data_Input;</span>
<span class="str"></span>
<span class="str">---------------------------</span>
<span class="str">--  Stream I/O of lines --</span>
<span class="str">---------------------------</span>
<span class="str">generic</span>
<span class="str">   Separator_Sequence : in String;  --  ends a line</span>
<span class="str">package Line_IO is</span>
<span class="str"></span>
<span class="str">   pragma Elaborate_Body;</span>
<span class="str"></span>
<span class="str">   procedure Put_Line (Item : String) is null;</span>
<span class="str">   -- not used in this program</span>
<span class="str"></span>
<span class="str">   function Get_Line return String;</span>
<span class="str"></span>
<span class="str">end Line_IO;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">with Ada.Streams.Stream_IO;</span>
<span class="str"></span>
<span class="str">package body Line_IO is</span>
<span class="str"></span>
<span class="str">   use Ada.Streams;</span>
<span class="str"></span>
<span class="str">   Stdin : Stream_IO.File_Type;</span>
<span class="str"></span>
<span class="str">   -- Types etc., status variables, and the buffer.</span>
<span class="str"></span>
<span class="str">   BUFSIZ: constant := 8_192;</span>
<span class="str">   pragma Assert(Character&apos;Size = Stream_Element&apos;Size);</span>
<span class="str"></span>
<span class="str">   SL : constant Natural := Separator_Sequence&apos;Length;</span>
<span class="str"></span>
<span class="str">   subtype Extended_Buffer_Index is Positive range 1 .. BUFSIZ + SL;</span>
<span class="str">   subtype Buffer_Index is Extended_Buffer_Index</span>
<span class="str">     range Extended_Buffer_Index&apos;First .. Extended_Buffer_Index&apos;Last - SL;</span>
<span class="str">   subtype Extended_Bytes_Index is Stream_Element_Offset</span>
<span class="str">     range 1 .. Stream_Element_Offset(Extended_Buffer_Index&apos;Last);</span>
<span class="str">   subtype Bytes_Index is Extended_Bytes_Index</span>
<span class="str">     range Extended_Bytes_Index&apos;First</span>
<span class="str">     .. (Extended_Bytes_Index&apos;Last - Stream_Element_Offset(SL));</span>
<span class="str"></span>
<span class="str">   subtype Buffer_Data is String(Extended_Buffer_Index);</span>
<span class="str">   subtype Buffer_Bytes is Stream_Element_Array(Extended_Bytes_Index);</span>
<span class="str"></span>
<span class="str">   Buffer : Buffer_Data;</span>
<span class="str">   Bytes  : Buffer_Bytes;</span>
<span class="str">   for Bytes&apos;Address use Buffer&apos;Address;</span>
<span class="str">   pragma Import (Ada, Bytes);</span>
<span class="str"></span>
<span class="str">   -- start of next substring and last valid character in buffer</span>
<span class="str">   Position : Natural range 0 .. Extended_Buffer_Index&apos;Last;</span>
<span class="str">   Last     : Natural range 0 .. Buffer_Index&apos;Last;</span>
<span class="str">   End_Of_Input : Boolean;</span>
<span class="str"></span>
<span class="str">   function Get_Line return String is</span>
<span class="str"></span>
<span class="str">      procedure Reload is</span>
<span class="str">         --  fill Buffer with bytes available</span>
<span class="str">         Last_Filled : Stream_Element_Offset;</span>
<span class="str">      begin</span>
<span class="str">         if Last &lt; Buffer_Index&apos;Last then</span>
<span class="str">            raise Stream_IO.End_Error;</span>
<span class="str">         end if;</span>
<span class="str">         Stream_IO.Read(Stdin,</span>
<span class="str">           Item =&gt; Bytes(Bytes_Index),</span>
<span class="str">           Last =&gt; Last_Filled);</span>
<span class="str">         Last := Natural(Last_Filled);</span>
<span class="str">         Position := 1;</span>
<span class="str">         Buffer(Last + 1 .. Last + SL) := Separator_Sequence;</span>
<span class="str">      end Reload;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">      function Separator_Position return Natural is</span>
<span class="str">         --   index of next Separator_Sequence (may be sentinel)</span>
<span class="str">         pragma Inline(Separator_Position);</span>
<span class="str">         K : Extended_Buffer_Index := Position;</span>
<span class="str">      begin</span>
<span class="str">         while Buffer(K) /= Separator_Sequence(1) loop</span>
<span class="str">            K := K + 1;</span>
<span class="str">         end loop;</span>
<span class="str">         return K;</span>
<span class="str">      end Separator_Position;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">      Next_Separator : Natural range 0 .. Extended_Buffer_Index&apos;Last;</span>
<span class="str">   begin  -- Get_Line</span>
<span class="str"></span>
<span class="str">      if End_Of_Input then</span>
<span class="str">         raise Stream_IO.End_Error;</span>
<span class="str">      end if;</span>
<span class="str"></span>
<span class="str">      Next_Separator := Separator_Position;</span>
<span class="str"></span>
<span class="str">      if Next_Separator &gt; Last then</span>
<span class="str">         declare</span>
<span class="str">            Result : constant String := Buffer(Position .. Last);</span>
<span class="str">            subtype XString is String (1 .. Last - Position + 1);</span>
<span class="str">         begin</span>
<span class="str">            begin</span>
<span class="str">               Reload;</span>
<span class="str">               return XString(Result) &amp; Get_Line;</span>
<span class="str">            exception</span>
<span class="str">               when Stream_IO.End_Error =&gt;</span>
<span class="str">                  End_Of_Input := True;</span>
<span class="str">                  return XString(Result);</span>
<span class="str">            end;</span>
<span class="str">         end;</span>
<span class="str">      else</span>
<span class="str">         declare</span>
<span class="str">            Result : String renames Buffer(Position .. Next_Separator - 1);</span>
<span class="str">            subtype XString is String (1 .. Next_Separator - Position);</span>
<span class="str">         begin</span>
<span class="str">            Position := Next_Separator + SL;</span>
<span class="str">            return XString (Result);</span>
<span class="str">         end;</span>
<span class="str">      end if;</span>
<span class="str"></span>
<span class="str">      raise Program_Error;</span>
<span class="str">   end Get_Line;</span>
<span class="str"></span>
<span class="str"></span>
<span class="str">begin</span>
<span class="str">   Stream_IO.Open (Stdin,</span>
<span class="str">     Mode =&gt; Stream_IO.In_File,</span>
<span class="str">     Name =&gt; &quot;/dev/stdin&quot;);</span>
<span class="str"></span>
<span class="str">   Buffer(Buffer_Index&apos;Last + 1 .. Buffer&apos;Last) := Separator_Sequence;</span>
<span class="str">   Position := Buffer_Index&apos;Last + 1;</span>
<span class="str">   Last := Buffer_Index&apos;Last;</span>
<span class="str">   End_Of_Input := False;</span>
<span class="str">end Line_IO;</span>
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
GNAT 11.2.0


Tue, 03 May 2022 00:16:08 GMT

MAKE:
gnatchop -r -w knucleotide.gnat-2.gnat
splitting knucleotide.gnat-2.gnat into:
   knucleotide.adb
   string_fragments.ads
   string_fragments.adb
   data_input.ads
   data_input.adb
   line_io.ads
   line_io.adb
gnatmake -O3 -fomit-frame-pointer -march=ivybridge -gnatNp -f knucleotide.adb -o knucleotide.gnat-2.gnat_run 
x86_64-linux-gnu-gcc-11 -c -O3 -fomit-frame-pointer -march=ivybridge -gnatNp knucleotide.adb
x86_64-linux-gnu-gcc-11 -c -O3 -fomit-frame-pointer -march=ivybridge -gnatNp data_input.adb
x86_64-linux-gnu-gcc-11 -c -O3 -fomit-frame-pointer -march=ivybridge -gnatNp string_fragments.adb
x86_64-linux-gnu-gcc-11 -c -O3 -fomit-frame-pointer -march=ivybridge -gnatNp line_io.adb
knucleotide.gnat-2.gnat:706:07: warning: unreachable code
x86_64-linux-gnu-gnatbind-11 -x knucleotide.ali
x86_64-linux-gnu-gnatlink-11 knucleotide.ali -O3 -fomit-frame-pointer -march=ivybridge -o knucleotide.gnat-2.gnat_run

4.30s to complete and log all make actions

COMMAND LINE:
./knucleotide.gnat-2.gnat_run 0 &lt; knucleotide-input25000000.txt

PROGRAM OUTPUT:
A 30.295
T 30.151
C 19.800
G 19.754

AA 9.177
TA 9.132
AT 9.131
TT 9.091
CA 6.002
AC 6.001
AG 5.987
GA 5.984
CT 5.971
TC 5.971
GT 5.957
TG 5.956
CC 3.917
GC 3.911
CG 3.909
GG 3.902

1471758	GGT
446535	GGTA
47336	GGTATT
893	GGTATTTTAATT
893	GGTATTTTAATTTATAGT
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

