<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>regex-redux Fortran gfortran program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>regex-redux Fortran gfortran program</h1>
    <aside>
      <p><a href="../description/regexredux.html#regexredux">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">! The Computer Language Benchmarks Game</span>
<span class="slc">! https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">!</span>
<span class="slc">! Contributed by Tyler Funnell</span>
<span class="slc">! translation of GCC #5 by Jeremy Zerfas &amp; Zoltan Herczeg</span>
<span class="slc">! compilation: ifort -O3 -xHost -ipo -qopenmp regexredux.f90</span>


<span class="kwa">module</span> pcre2_mod
    <span class="kwa">use</span> iso_c_binding
    <span class="kwa">implicit none</span>

    <span class="kwa">type</span> var_str
        <span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=:),</span> allocatable <span class="opt">::</span> <span class="kwa">data</span>
        <span class="kwa">integer</span> <span class="opt">::</span> size
    <span class="kwa">end type</span>

    <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">),</span> <span class="kwa">parameter</span> <span class="opt">::</span> PCRE2_JIT_COMPLETE <span class="opt">=</span> <span class="kwd">int</span><span class="opt">(</span>z<span class="str">&apos;00000001&apos;</span><span class="opt">)</span>

    <span class="kwa">interface</span>
        <span class="slc">! void pcre2_code_free(pcre2_code *code)</span>
        <span class="kwa">subroutine</span> <span class="kwd">pcre2_code_free</span><span class="opt">(</span>code<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_code_free_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> code
        <span class="kwa">end subroutine</span>

        <span class="slc">! pcre2_code *pcre2_compile(PCRE2_SPTR pattern, PCRE2_SIZE length,</span>
        <span class="slc">!                           uint32_t options, int *errorcode,</span>
        <span class="slc">!                           PCRE2_SIZE *erroroffset,</span>
        <span class="slc">!                           pcre2_compile_context *ccontext)</span>
        <span class="kwa">function</span> pcre2_compile <span class="opt">&amp;</span>
                <span class="opt">(</span>pattern<span class="opt">,</span> length<span class="opt">,</span> <span class="kwa">options</span><span class="opt">,</span> errorcode<span class="opt">,</span> erroroffset<span class="opt">,</span> ccontext<span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>code<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_compile_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> code
            <span class="kwa">character</span><span class="opt">(</span>kind<span class="opt">=</span>c_char<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">) ::</span> <span class="kwd">pattern</span><span class="opt">(*)</span>
            <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> length<span class="opt">,</span> <span class="kwa">options</span>
            <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>out<span class="opt">) ::</span> errorcode
            <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>out<span class="opt">) ::</span> erroroffset
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> ccontext
        <span class="kwa">end function</span>

        <span class="slc">! PCRE2_SIZE *pcre2_get_ovector_pointer(pcre2_match_data *match_data)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_get_ovector_pointer</span><span class="opt">(</span>match_data<span class="opt">)</span> <span class="kwd">result</span><span class="opt">(</span>ret<span class="opt">) &amp;</span>
                <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_get_ovector_pointer_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> ret
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> match_data
        <span class="kwa">end function</span>

        <span class="slc">! int pcre2_jit_compile(pcre2_code *code, uint32_t options)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_jit_compile</span><span class="opt">(</span>code<span class="opt">,</span> <span class="kwa">options</span><span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>errorcode<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_jit_compile_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">integer</span> <span class="opt">::</span> errorcode
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> code
            <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> <span class="kwa">options</span>
        <span class="kwa">end function</span>

        <span class="slc">! int pcre2_jit_match(const pcre2_code *code, PCRE2_SPTR subject,</span>
        <span class="slc">!                     PCRE2_SIZE length, PCRE2_SIZE startoffset,</span>
        <span class="slc">!                     uint32_t options, pcre2_match_data *match_data,</span>
        <span class="slc">!                     pcre2_match_context *mcontext)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_jit_match</span> <span class="opt">(</span>code<span class="opt">,</span> subject<span class="opt">,</span> length<span class="opt">,</span> startoffset<span class="opt">,</span> <span class="kwa">options</span><span class="opt">, &amp;</span>
                match_data<span class="opt">,</span> mcontext<span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>ret<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_jit_match_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">integer</span> <span class="opt">::</span> ret
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> code<span class="opt">,</span> match_data<span class="opt">,</span> mcontext
            <span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=</span><span class="num">1</span><span class="opt">,</span> kind<span class="opt">=</span>c_char<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">) ::</span> <span class="kwd">subject</span><span class="opt">(*)</span>
            <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> length<span class="opt">,</span> startoffset<span class="opt">,</span> <span class="kwa">options</span>
        <span class="kwa">end function</span>

        <span class="slc">! void pcre2_jit_stack_assign(pcre2_match_context *mcontext,</span>
        <span class="slc">!   pcre2_jit_callback callback_function, void *callback_data)</span>
        <span class="kwa">subroutine</span> pcre2_jit_stack_assign <span class="opt">&amp;</span>
                <span class="opt">(</span>mcontext<span class="opt">,</span> callback_function<span class="opt">,</span> callback_data<span class="opt">) &amp;</span>
                <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_jit_stack_assign_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> mcontext<span class="opt">,</span> callback_function<span class="opt">, &amp;</span>
                callback_data
        <span class="kwa">end subroutine</span>

        <span class="slc">! pcre2_jit_stack *pcre2_jit_stack_create(</span>
        <span class="slc">!   PCRE2_SIZE startsize, PCRE2_SIZE maxsize,</span>
        <span class="slc">!   pcre2_general_context *gcontext)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_jit_stack_create</span><span class="opt">(</span>startsize<span class="opt">,</span> maxsize<span class="opt">,</span> gcontext<span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>stack<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_jit_stack_create_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> stack
            <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> startsize<span class="opt">,</span> maxsize
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> gcontext
        <span class="kwa">end function</span>

        <span class="slc">! void pcre2_jit_stack_free(pcre2_jit_stack *jit_stack)</span>
        <span class="kwa">subroutine</span> <span class="kwd">pcre2_jit_stack_free</span><span class="opt">(</span>jit_stack<span class="opt">) &amp;</span>
                <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_jit_stack_free_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> jit_stack
        <span class="kwa">end subroutine</span>

        <span class="slc">! pcre2_match_context *pcre2_match_context_create(</span>
        <span class="slc">!   pcre2_general_context *gcontext)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_match_context_create</span><span class="opt">(</span>gcontext<span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>mcontext<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_match_context_create_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> mcontext
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> gcontext
        <span class="kwa">end function</span>

        <span class="slc">! void pcre2_match_context_free(pcre2_match_context *mcontext)</span>
        <span class="kwa">subroutine</span> <span class="kwd">pcre2_match_context_free</span><span class="opt">(</span>mcontext<span class="opt">) &amp;</span>
                <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_match_context_free_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> mcontext
        <span class="kwa">end subroutine</span>

        <span class="slc">! pcre2_match_data *pcre2_match_data_create(</span>
        <span class="slc">!   uint32_t ovecsize, pcre2_general_context *gcontext)</span>
        <span class="kwa">function</span> <span class="kwd">pcre2_match_data_create</span><span class="opt">(</span>ovecsize<span class="opt">,</span> gcontext<span class="opt">) &amp;</span>
                <span class="kwd">result</span><span class="opt">(</span>mdata<span class="opt">)</span> <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_match_data_create_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> mdata
            <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> ovecsize
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> gcontext
        <span class="kwa">end function</span>

        <span class="slc">! void pcre2_match_data_free(pcre2_match_data *match_data)</span>
        <span class="kwa">subroutine</span> <span class="kwd">pcre2_match_data_free</span><span class="opt">(</span>match_data<span class="opt">) &amp;</span>
                <span class="kwd">bind</span><span class="opt">(</span>c<span class="opt">,</span> name<span class="opt">=</span><span class="str">&apos;pcre2_match_data_free_8&apos;</span><span class="opt">)</span>
            import
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">),</span> value <span class="opt">::</span> match_data
        <span class="kwa">end subroutine</span>
    <span class="kwa">end interface</span>

    <span class="kwa">contains</span>
        <span class="kwa">subroutine</span> <span class="kwd">replace</span><span class="opt">(</span>pattern<span class="opt">,</span> replacement<span class="opt">,</span> src_string<span class="opt">,</span> dst_string<span class="opt">, &amp;</span>
                mcontext<span class="opt">,</span> mdata<span class="opt">)</span>
            <span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=*),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">) ::</span> pattern<span class="opt">,</span> replacement
            <span class="kwa">type</span><span class="opt">(</span>var_str<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">) ::</span> src_string
            <span class="kwa">type</span><span class="opt">(</span>var_str<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>inout<span class="opt">) ::</span> dst_string
            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">),</span> <span class="kwd">intent</span><span class="opt">(</span>in<span class="opt">) ::</span> mcontext<span class="opt">,</span> mdata

            <span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=:),</span> allocatable <span class="opt">::</span> temp

            <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> regex<span class="opt">,</span> c_match
            <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">),</span> <span class="kwa">pointer</span> <span class="opt">::</span> <span class="kwd">match</span><span class="opt">(:)</span>
            <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">) ::</span> errorcode<span class="opt">,</span> pos
            <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">) ::</span> erroroffset


            c_match <span class="opt">=</span> <span class="kwd">pcre2_get_ovector_pointer</span><span class="opt">(</span>mdata<span class="opt">)</span>
            <span class="kwa">call</span> <span class="kwd">c_f_pointer</span><span class="opt">(</span>c_match<span class="opt">,</span> match<span class="opt">, [</span><span class="num">2</span><span class="opt">])</span>

            regex <span class="opt">=</span> <span class="kwd">pcre2_compile</span><span class="opt">(</span>pattern<span class="opt">,</span> <span class="kwd">len</span><span class="opt">(</span>pattern<span class="opt">),</span> <span class="num">0</span>_c_int<span class="opt">,</span> errorcode<span class="opt">, &amp;</span>
                erroroffset<span class="opt">,</span> c_null_ptr<span class="opt">)</span>
            errorcode <span class="opt">=</span> <span class="kwd">pcre2_jit_compile</span><span class="opt">(</span>regex<span class="opt">,</span> PCRE2_JIT_COMPLETE<span class="opt">)</span>

            pos <span class="opt">=</span> <span class="num">0</span>

            <span class="slc">! Find each match of the pattern in src_string and append the</span>
            <span class="slc">! characters preceding each match and the replacement text to</span>
            <span class="slc">! dst_string.</span>
            <span class="kwa">do</span>
                errorcode <span class="opt">=</span> <span class="kwd">pcre2_jit_match</span><span class="opt">(</span>regex<span class="opt">,</span> src_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">, &amp;</span>
                    src_string<span class="opt">%</span>size<span class="opt">,</span> pos<span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> mdata<span class="opt">,</span> mcontext<span class="opt">)</span>

                <span class="kwa">if</span> <span class="opt">(</span>errorcode <span class="opt">&lt;</span> <span class="num">0</span><span class="opt">)</span> exit

                <span class="slc">! Allocate more memory for dst_string if there is not enough</span>
                <span class="slc">! space for the characters preceding the match and the</span>
                <span class="slc">! replacement text.</span>
                <span class="kwa">do</span>
                    <span class="kwa">if</span> <span class="opt">(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="kwd">match</span><span class="opt">(</span><span class="num">1</span><span class="opt">) -</span> pos <span class="opt">+</span> <span class="kwd">len</span><span class="opt">(</span>replacement<span class="opt">) &lt;= &amp;</span>
                        <span class="kwd">len</span><span class="opt">(</span>dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">))</span> exit

                    <span class="kwd">allocate</span> <span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span><span class="kwd">len</span><span class="opt">(</span>dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">) *</span> <span class="num">2</span><span class="opt">) ::</span> temp<span class="opt">)</span>
                    <span class="kwd">temp</span><span class="opt">(</span><span class="num">1</span><span class="opt">:</span>dst_string<span class="opt">%</span>size<span class="opt">) =</span> dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">(:</span>dst_string<span class="opt">%</span>size<span class="opt">)</span>
                    <span class="kwa">call</span> <span class="kwd">move_alloc</span><span class="opt">(</span>temp<span class="opt">,</span> dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
                <span class="kwa">end do</span>

                <span class="slc">! Append the characters preceding the match and the replacement</span>
                <span class="slc">! text to dst_string and update the size of dst_string.</span>
                dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">( &amp;</span>
                    <span class="opt">(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="num">1</span><span class="opt">):(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="kwd">match</span><span class="opt">(</span><span class="num">1</span><span class="opt">) -</span> pos<span class="opt">) &amp;</span>
                <span class="opt">) =</span> src_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">((</span>pos <span class="opt">+</span> <span class="num">1</span><span class="opt">):</span><span class="kwd">match</span><span class="opt">(</span><span class="num">1</span><span class="opt">))</span>
                dst_string<span class="opt">%</span>size <span class="opt">=</span> dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="kwd">match</span><span class="opt">(</span><span class="num">1</span><span class="opt">) -</span> pos

                dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">( &amp;</span>
                    <span class="opt">(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="num">1</span><span class="opt">):(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="kwd">len</span><span class="opt">(</span>replacement<span class="opt">)) &amp;</span>
                <span class="opt">) =</span> replacement
                dst_string<span class="opt">%</span>size <span class="opt">=</span> dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="kwd">len</span><span class="opt">(</span>replacement<span class="opt">)</span>

                <span class="slc">! Update pos to continue searching after the current match.</span>
                pos <span class="opt">=</span> <span class="kwd">match</span><span class="opt">(</span><span class="num">2</span><span class="opt">)</span>
            <span class="kwa">end do</span>

        <span class="kwa">call</span> <span class="kwd">pcre2_code_free</span><span class="opt">(</span>regex<span class="opt">)</span>

        <span class="slc">! Allocate more memory for dst_string if there is not enough space for</span>
        <span class="slc">! the characters following the last match (or the entire src_string if</span>
        <span class="slc">! there was no match).</span>
        <span class="kwa">do</span>
            <span class="kwa">if</span> <span class="opt">( &amp;</span>
                dst_string<span class="opt">%</span>size <span class="opt">+</span> src_string<span class="opt">%</span>size <span class="opt">-</span> pos <span class="opt">&lt;= &amp;</span>
                <span class="kwd">len</span><span class="opt">(</span>dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">) &amp;</span> 
            <span class="opt">)</span> exit

            <span class="kwd">allocate</span> <span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span><span class="kwd">len</span><span class="opt">(</span>dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">) *</span> <span class="num">2</span><span class="opt">) ::</span> temp<span class="opt">)</span>
            <span class="kwd">temp</span><span class="opt">(</span><span class="num">1</span><span class="opt">:</span>dst_string<span class="opt">%</span>size<span class="opt">) =</span> dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">(:</span>dst_string<span class="opt">%</span>size<span class="opt">)</span>
            <span class="kwa">call</span> <span class="kwd">move_alloc</span><span class="opt">(</span>temp<span class="opt">,</span> dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
        <span class="kwa">end do</span>

        <span class="slc">! Append the characters following the last match (or the entire</span>
        <span class="slc">! src_string if there was no match) to dst_string and update the size</span>
        <span class="slc">! of dst_string.</span>
        dst_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">( &amp;</span>
            <span class="opt">(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> <span class="num">1</span><span class="opt">):(</span>dst_string<span class="opt">%</span>size <span class="opt">+</span> src_string<span class="opt">%</span>size <span class="opt">-</span> pos<span class="opt">) &amp;</span>
        <span class="opt">) =</span> src_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">((</span>pos <span class="opt">+</span> <span class="num">1</span><span class="opt">):</span>src_string<span class="opt">%</span>size<span class="opt">)</span>
        dst_string<span class="opt">%</span>size <span class="opt">=</span> dst_string<span class="opt">%</span>size <span class="opt">+</span> src_string<span class="opt">%</span>size <span class="opt">-</span> pos

        <span class="kwa">end subroutine</span>
<span class="kwa">end module</span> pcre2_mod

<span class="kwa">program</span> regexredux
    <span class="kwa">use</span> iso_fortran_env
    <span class="kwa">use</span> iso_c_binding
    <span class="kwa">use</span> pcre2_mod
    <span class="kwa">implicit none</span>

    <span class="kwa">type</span> const_str
        <span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=:),</span> allocatable <span class="opt">::</span> <span class="kwa">data</span>
    <span class="kwa">end type</span>

    <span class="kwa">type</span><span class="opt">(</span>const_str<span class="opt">),</span> <span class="kwa">dimension</span><span class="opt">(:),</span> allocatable <span class="opt">::</span> count_info
    <span class="kwa">type</span><span class="opt">(</span>const_str<span class="opt">),</span> <span class="kwa">dimension</span><span class="opt">(:, :),</span> allocatable <span class="opt">::</span> replace_info

    <span class="kwa">type</span><span class="opt">(</span>var_str<span class="opt">) ::</span> input<span class="opt">,</span> temp<span class="opt">,</span> sequences<span class="opt">,</span> prereplace_string<span class="opt">, &amp;</span>
        postreplace_string
    <span class="kwa">integer</span> <span class="opt">::</span> input_size<span class="opt">,</span> info_count<span class="opt">,</span> i

    <span class="kwa">type</span><span class="opt">(</span>c_ptr<span class="opt">) ::</span> mdata<span class="opt">,</span> mcontext<span class="opt">,</span> stack<span class="opt">,</span> regex<span class="opt">,</span> c_match
    <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">),</span> <span class="kwa">pointer</span> <span class="opt">::</span> <span class="kwd">match</span><span class="opt">(:)</span>
    <span class="kwa">integer</span><span class="opt">(</span>c_size_t<span class="opt">) ::</span> erroroffset
    <span class="kwa">integer</span><span class="opt">(</span>c_int<span class="opt">) ::</span> errorcode<span class="opt">,</span> pos


    count_info <span class="opt">= [ &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;agggtaaa|tttaccct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;[cgt]gggtaaa|tttaccc[acg]&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;a[act]ggtaaa|tttacc[agt]t&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;ag[act]gtaaa|tttac[agt]ct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;agg[act]taaa|ttta[agt]cct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;aggg[acg]aaa|ttt[cgt]ccct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;agggt[cgt]aa|tt[acg]accct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;agggta[cgt]a|t[acg]taccct&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;agggtaa[cgt]|[acg]ttaccct&apos;</span><span class="opt">) &amp;</span>
    <span class="opt">]</span>
    replace_info <span class="opt">=</span> <span class="kwd">reshape</span><span class="opt">([ &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;tHa[Nt]&apos;</span><span class="opt">),</span> <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;&lt;4&gt;&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;aND|caN|Ha[DS]|WaS&apos;</span><span class="opt">),</span> <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;&lt;3&gt;&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;a[NSt]|BY&apos;</span><span class="opt">),</span> <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;&lt;2&gt;&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;&lt;[^&gt;]*&gt;&apos;</span><span class="opt">),</span> <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;|&apos;</span><span class="opt">), &amp;</span>
        <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;\|[^|][^|]*\|&apos;</span><span class="opt">),</span> <span class="kwd">const_str</span><span class="opt">(</span><span class="str">&apos;-&apos;</span><span class="opt">) &amp;</span>
    <span class="opt">], [</span><span class="num">2</span><span class="opt">,</span> <span class="num">5</span><span class="opt">])</span>

    <span class="kwa">open</span><span class="opt">(</span>unit<span class="opt">=</span>input_unit<span class="opt">,</span> action<span class="opt">=</span><span class="str">&quot;read&quot;</span><span class="opt">,</span> form<span class="opt">=</span><span class="str">&quot;unformatted&quot;</span><span class="opt">,</span> access<span class="opt">=</span><span class="str">&quot;stream&quot;</span><span class="opt">)</span>
    <span class="kwa">inquire</span><span class="opt">(</span>unit<span class="opt">=</span>input_unit<span class="opt">,</span> size<span class="opt">=</span>input_size<span class="opt">)</span>
    <span class="kwd">allocate</span><span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=</span>input_size<span class="opt">) ::</span> input<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="kwa">read</span><span class="opt">(</span>input_unit<span class="opt">)</span> input<span class="opt">%</span><span class="kwa">data</span>
    <span class="kwa">close</span><span class="opt">(</span>input_unit<span class="opt">)</span>

    input<span class="opt">%</span>size <span class="opt">=</span> input_size

    <span class="slc">!$omp parallel private(mcontext, stack, mdata)</span>
    mcontext <span class="opt">=</span> <span class="kwd">pcre2_match_context_create</span><span class="opt">(</span>c_null_ptr<span class="opt">)</span>
    stack <span class="opt">=</span> <span class="kwd">pcre2_jit_stack_create</span><span class="opt">(</span><span class="num">16384</span>_c_size_t<span class="opt">,</span> <span class="num">16384</span>_c_size_t<span class="opt">,</span> c_null_ptr<span class="opt">)</span>
    <span class="kwa">call</span> <span class="kwd">pcre2_jit_stack_assign</span><span class="opt">(</span>mcontext<span class="opt">,</span> c_null_ptr<span class="opt">,</span> stack<span class="opt">)</span>
    mdata <span class="opt">=</span> <span class="kwd">pcre2_match_data_create</span><span class="opt">(</span><span class="num">16</span>_c_size_t<span class="opt">,</span> c_null_ptr<span class="opt">)</span>

    <span class="slc">!$omp single</span>
    <span class="kwd">allocate</span> <span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=</span><span class="num">16384</span><span class="opt">) ::</span> sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="kwa">call</span> <span class="kwd">replace</span><span class="opt">(</span><span class="str">&apos;&gt;.*</span><span class="esc">\n</span><span class="str">|</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">,</span> <span class="str">&apos;&apos;</span><span class="opt">,</span> input<span class="opt">,</span> sequences<span class="opt">,</span> mcontext<span class="opt">,</span> mdata<span class="opt">)</span>
    <span class="kwd">deallocate</span><span class="opt">(</span>input<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="slc">!$omp end single</span>

    <span class="slc">! We&apos;ll use two strings when doing all the replacements, searching</span>
    <span class="slc">! for patterns in prereplace_string and using postreplace_string to</span>
    <span class="slc">! store the string after the replacements have been made. After</span>
    <span class="slc">! each iteration these two then get swapped. Start out with both</span>
    <span class="slc">! strings having the same capacity as the sequences string and also</span>
    <span class="slc">! copy the sequences string into prereplace_string for the initial</span>
    <span class="slc">! iteration.</span>
    <span class="slc">!$omp single</span>
    <span class="kwd">allocate</span><span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=</span><span class="kwd">len</span><span class="opt">(</span>sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">)) ::</span> prereplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="kwd">allocate</span><span class="opt">(</span><span class="kwa">character</span><span class="opt">(</span>len<span class="opt">=</span><span class="kwd">len</span><span class="opt">(</span>sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">)) ::</span> postreplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    prereplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">(:) =</span> sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">(:)</span>
    prereplace_string<span class="opt">%</span>size <span class="opt">=</span> sequences<span class="opt">%</span>size
    postreplace_string<span class="opt">%</span>size <span class="opt">=</span> <span class="num">0</span>

    <span class="slc">! Iterate through all the replacement patterns and their</span>
    <span class="slc">! replacements in replace_info.</span>
    <span class="kwa">do</span> i <span class="opt">=</span> <span class="num">1</span><span class="opt">,</span> <span class="kwd">size</span><span class="opt">(</span>replace_info<span class="opt">,</span> <span class="num">2</span><span class="opt">)</span>
        <span class="kwa">call</span> <span class="kwd">replace</span><span class="opt">( &amp;</span>
            <span class="kwd">replace_info</span><span class="opt">(</span><span class="num">1</span><span class="opt">,</span> i<span class="opt">)%</span><span class="kwa">data</span><span class="opt">,</span> <span class="kwd">replace_info</span><span class="opt">(</span><span class="num">2</span><span class="opt">,</span> i<span class="opt">)%</span><span class="kwa">data</span><span class="opt">, &amp;</span>
            prereplace_string<span class="opt">,</span> postreplace_string<span class="opt">,</span> mcontext<span class="opt">,</span> mdata<span class="opt">)</span>

        <span class="kwa">call</span> <span class="kwd">move_alloc</span><span class="opt">(</span>prereplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">,</span> temp<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
        <span class="kwa">call</span> <span class="kwd">move_alloc</span><span class="opt">(</span>postreplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">,</span> prereplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
        prereplace_string<span class="opt">%</span>size <span class="opt">=</span> postreplace_string<span class="opt">%</span>size
        <span class="kwa">call</span> <span class="kwd">move_alloc</span><span class="opt">(</span>temp<span class="opt">%</span><span class="kwa">data</span><span class="opt">,</span> postreplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
        postreplace_string<span class="opt">%</span>size <span class="opt">=</span> <span class="num">0</span>
    <span class="kwa">end do</span>

    <span class="kwd">deallocate</span><span class="opt">(</span>prereplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="kwd">deallocate</span><span class="opt">(</span>postreplace_string<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>
    <span class="slc">!$omp end single nowait</span>

    <span class="slc">! Iterate through all the count patterns in count_info[] and perform</span>
    <span class="slc">! the counting for each one on a different thread if available.</span>
    <span class="slc">!$omp do schedule(dynamic) ordered &amp;</span>
    <span class="slc">!$omp private(errorcode, erroroffset, info_count, pos, regex, c_match, match)</span>
    <span class="kwa">do</span> i <span class="opt">=</span> <span class="num">1</span><span class="opt">,</span> <span class="kwd">size</span><span class="opt">(</span>count_info<span class="opt">)</span>
        errorcode <span class="opt">=</span> <span class="num">0</span>
        info_count <span class="opt">=</span> <span class="num">0</span>
        pos <span class="opt">=</span> <span class="num">0</span>

        c_match <span class="opt">=</span> <span class="kwd">pcre2_get_ovector_pointer</span><span class="opt">(</span>mdata<span class="opt">)</span>
        <span class="kwa">call</span> <span class="kwd">c_f_pointer</span><span class="opt">(</span>c_match<span class="opt">,</span> match<span class="opt">, [</span><span class="num">2</span><span class="opt">])</span>

        <span class="slc">! Compile and study pattern.</span>
        regex <span class="opt">=</span> <span class="kwd">pcre2_compile</span><span class="opt">( &amp;</span>
            <span class="kwd">count_info</span><span class="opt">(</span>i<span class="opt">)%</span><span class="kwa">data</span><span class="opt">,</span> <span class="kwd">len</span><span class="opt">(</span><span class="kwd">count_info</span><span class="opt">(</span>i<span class="opt">)%</span><span class="kwa">data</span><span class="opt">), &amp;</span>
            <span class="num">0</span>_c_int<span class="opt">,</span> errorcode<span class="opt">,</span> erroroffset<span class="opt">,</span> c_null_ptr<span class="opt">)</span>
        errorcode <span class="opt">=</span> <span class="kwd">pcre2_jit_compile</span><span class="opt">(</span>regex<span class="opt">,</span> PCRE2_JIT_COMPLETE<span class="opt">)</span>

        <span class="slc">! Find each match of the pattern in the sequences string and</span>
        <span class="slc">! increment count for each match.</span>
        <span class="kwa">do</span>
            errorcode <span class="opt">=</span> <span class="kwd">pcre2_jit_match</span><span class="opt">( &amp;</span>
                regex<span class="opt">,</span> sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">,</span> sequences<span class="opt">%</span>size<span class="opt">,</span> pos<span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> mdata<span class="opt">,</span> mcontext<span class="opt">)</span>

            <span class="kwa">if</span> <span class="opt">(</span>errorcode <span class="opt">&lt;</span> <span class="num">0</span><span class="opt">)</span> exit

            info_count <span class="opt">=</span> info_count <span class="opt">+</span> <span class="num">1</span>
            pos <span class="opt">=</span> <span class="kwd">match</span><span class="opt">(</span><span class="num">2</span><span class="opt">)</span>
        <span class="kwa">end do</span>

        <span class="kwa">call</span> <span class="kwd">pcre2_code_free</span><span class="opt">(</span>regex<span class="opt">)</span>

        <span class="slc">! Print the count for each pattern in the correct order.</span>
        <span class="slc">!$omp ordered</span>
        <span class="kwa">print</span> <span class="str">&apos;(A, &quot; &quot;, I0)&apos;</span><span class="opt">,</span> <span class="kwd">count_info</span><span class="opt">(</span>i<span class="opt">)%</span><span class="kwa">data</span><span class="opt">,</span> info_count
        <span class="slc">!$omp end ordered</span>
    <span class="kwa">end do</span>
    <span class="slc">!$omp end do</span>

    <span class="kwa">call</span> <span class="kwd">pcre2_match_context_free</span><span class="opt">(</span>mcontext<span class="opt">)</span>
    <span class="kwa">call</span> <span class="kwd">pcre2_jit_stack_free</span><span class="opt">(</span>stack<span class="opt">)</span>
    <span class="kwa">call</span> <span class="kwd">pcre2_match_data_free</span><span class="opt">(</span>mdata<span class="opt">)</span>
    <span class="slc">!$omp end parallel</span>

    <span class="kwd">deallocate</span><span class="opt">(</span>sequences<span class="opt">%</span><span class="kwa">data</span><span class="opt">)</span>

    <span class="slc">! Print the size of the original input, the size of the input without the</span>
    <span class="slc">! sequence descriptions &amp; new lines, and the size after having made all the</span>
    <span class="slc">! replacements.</span>
    <span class="kwa">print</span> <span class="str">&apos;(/ I0 / I0 / I0)&apos;</span><span class="opt">,</span> input_size<span class="opt">,</span> sequences<span class="opt">%</span>size<span class="opt">,</span> prereplace_string<span class="opt">%</span>size

<span class="kwa">end program</span> regexredux
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
GNU Fortran (Ubuntu 9.3.0-10ubuntu2) 9.3.0


Wed, 01 Jul 2020 21:05:39 GMT

MAKE:
/usr/bin/gfortran -pipe -O3 -fomit-frame-pointer -march=ivybridge  -fopenmp regexredux.f95 -o regexredux.gfortran_run -Xlinker -lpcre2-8
rm regexredux.f95

2.01s to complete and log all make actions

COMMAND LINE:
./regexredux.gfortran_run 0 &lt; regexredux-input50000.txt

PROGRAM FAILED 


PROGRAM OUTPUT:

At line 267 of file regexredux.f95 (unit = 5, file = 'stdin')
Fortran runtime error: Cannot change ACCESS parameter in OPEN statement

Error termination. Backtrace:
#0  0x7f7c51f80cd1 in ???
#1  0x7f7c51f81819 in ???
#2  0x7f7c51f824ef in ???
#3  0x7f7c521bde63 in ???
#4  0x7f7c521befa5 in ???
#5  0x55b20af5019e in ???
#6  0x55b20af4f2de in ???
#7  0x7f7c51d540b2 in ???
#8  0x55b20af4f31d in ???
#9  0xffffffffffffffff in ???
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/CONTRIBUTING.md#contribute-source-code-for-measurement"><span>Contribute your own program</span></a>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

